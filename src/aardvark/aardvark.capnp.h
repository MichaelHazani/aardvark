// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: aardvark.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 7000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(dba3941be7c535bc);
CAPNP_DECLARE_SCHEMA(ce8fd91680a68bd1);
enum class Type_ce8fd91680a68bd1: uint16_t {
  INVALID,
  D3D11_TEXTURE2_D,
};
CAPNP_DECLARE_ENUM(Type, ce8fd91680a68bd1);
CAPNP_DECLARE_SCHEMA(b4ed8876f3f9250a);
enum class Format_b4ed8876f3f9250a: uint16_t {
  R8G8B8A8,
  B8G8R8A8,
};
CAPNP_DECLARE_ENUM(Format, b4ed8876f3f9250a);
CAPNP_DECLARE_SCHEMA(cc0f1792d149c313);
CAPNP_DECLARE_SCHEMA(e8ffa9a9709eb047);
CAPNP_DECLARE_SCHEMA(b02007dd270cc5c9);
CAPNP_DECLARE_SCHEMA(9899eaba8cbdf2c0);
CAPNP_DECLARE_SCHEMA(bb67002f6c8e6813);
CAPNP_DECLARE_SCHEMA(f2cfde5589c790d1);
CAPNP_DECLARE_SCHEMA(c63d22eedfe945e3);
CAPNP_DECLARE_SCHEMA(8015c5a053ba10f7);
CAPNP_DECLARE_SCHEMA(cb0fc7ad8b5a13e0);
CAPNP_DECLARE_SCHEMA(cb7ed1098aa53774);
CAPNP_DECLARE_SCHEMA(8bba34fae0ebb16d);
CAPNP_DECLARE_SCHEMA(e10179e87d664294);
CAPNP_DECLARE_SCHEMA(936192ac58f1de7e);
CAPNP_DECLARE_SCHEMA(dcaa723e1ce3648b);
CAPNP_DECLARE_SCHEMA(af5b8ea815d4c48a);
CAPNP_DECLARE_SCHEMA(e6824aebf526d4e8);
CAPNP_DECLARE_SCHEMA(ea5196d27e4e0492);
CAPNP_DECLARE_SCHEMA(ab769bf8457ea26d);
CAPNP_DECLARE_SCHEMA(e865e502fce885ec);
CAPNP_DECLARE_SCHEMA(e60de5b22d11d2d0);
enum class Type_e60de5b22d11d2d0: uint16_t {
  DOWN,
  UP,
  ENTER,
  LEAVE,
  MOVE,
};
CAPNP_DECLARE_ENUM(Type, e60de5b22d11d2d0);
CAPNP_DECLARE_SCHEMA(e829b4bc9d70eb7e);
CAPNP_DECLARE_SCHEMA(cdfe97b4cee53bb9);
CAPNP_DECLARE_SCHEMA(ffd2e84ee76e83ba);
CAPNP_DECLARE_SCHEMA(ff3efec28716255a);
CAPNP_DECLARE_SCHEMA(da268697d5366153);
CAPNP_DECLARE_SCHEMA(ee91b214c65dd724);
CAPNP_DECLARE_SCHEMA(81074db71ab98254);
CAPNP_DECLARE_SCHEMA(f5cccdbd92cd311a);
enum class Type_f5cccdbd92cd311a: uint16_t {
  INVALID,
  ENTER_RANGE,
  LEAVE_RANGE,
  START_GRAB,
  END_GRAB,
  ENTER_HOOK_RANGE,
  LEAVE_HOOK_RANGE,
};
CAPNP_DECLARE_ENUM(Type, f5cccdbd92cd311a);
CAPNP_DECLARE_SCHEMA(bb3e161d2679685d);
CAPNP_DECLARE_SCHEMA(e12cca80f5108a39);
CAPNP_DECLARE_SCHEMA(c9c7fc9085d51acf);
CAPNP_DECLARE_SCHEMA(ff2e95d815609365);
CAPNP_DECLARE_SCHEMA(c573c27aa036b25f);
enum class Type_c573c27aa036b25f: uint16_t {
  INVALID,
  SPHERE,
};
CAPNP_DECLARE_ENUM(Type, c573c27aa036b25f);
CAPNP_DECLARE_SCHEMA(cef52746090f960e);
CAPNP_DECLARE_SCHEMA(d941283d2e432ce6);
enum class Type_d941283d2e432ce6: uint16_t {
  INVALID,
  CONTAINER,
  ORIGIN,
  TRANSFORM,
  MODEL,
  PANEL,
  POKER,
  GRABBABLE,
  HANDLE,
  GRABBER,
  CUSTOM,
};
CAPNP_DECLARE_ENUM(Type, d941283d2e432ce6);
CAPNP_DECLARE_SCHEMA(f1e09ba70d4ac430);
CAPNP_DECLARE_SCHEMA(cfe9abb40aa7aea4);
CAPNP_DECLARE_SCHEMA(b8373e593ee6b1da);
CAPNP_DECLARE_SCHEMA(dc8472282d3a40fb);
CAPNP_DECLARE_SCHEMA(8a66d1ef1c56b84f);
CAPNP_DECLARE_SCHEMA(fc31dffeb8e8c3d2);
CAPNP_DECLARE_SCHEMA(fa2e11af02f503a9);
CAPNP_DECLARE_SCHEMA(8939659054774402);
CAPNP_DECLARE_SCHEMA(b9e343036c482ec1);
CAPNP_DECLARE_SCHEMA(de8c49e5e60c78ec);
CAPNP_DECLARE_SCHEMA(9349631ab9cbcbb2);
CAPNP_DECLARE_SCHEMA(c9957ef3f1a43b2c);
CAPNP_DECLARE_SCHEMA(fdaa564f79a910e9);
CAPNP_DECLARE_SCHEMA(dcfdc1bffab9884a);
CAPNP_DECLARE_SCHEMA(bd6a0991599662d5);
CAPNP_DECLARE_SCHEMA(dd4d9d4d3811d454);
CAPNP_DECLARE_SCHEMA(e6bbdabf4790a569);
CAPNP_DECLARE_SCHEMA(a0281ad040f44f24);
CAPNP_DECLARE_SCHEMA(cadd7a2e60f68024);
CAPNP_DECLARE_SCHEMA(bce429661ca5e624);
CAPNP_DECLARE_SCHEMA(d6a50fd325ec3b67);
CAPNP_DECLARE_SCHEMA(a1fc6551ff04f7cf);
CAPNP_DECLARE_SCHEMA(d301ea879688a412);
CAPNP_DECLARE_SCHEMA(a87ef5a02cc9f0ab);
CAPNP_DECLARE_SCHEMA(fc853a643c028139);
CAPNP_DECLARE_SCHEMA(ac22fff5a9e71b08);

}  // namespace schemas
}  // namespace capnp


struct AvSharedTextureInfo {
  AvSharedTextureInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_ce8fd91680a68bd1 Type;

  typedef ::capnp::schemas::Format_b4ed8876f3f9250a Format;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dba3941be7c535bc, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvVector {
  AvVector() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cc0f1792d149c313, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvColor {
  AvColor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e8ffa9a9709eb047, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvQuaternion {
  AvQuaternion() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b02007dd270cc5c9, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvTransform {
  AvTransform() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9899eaba8cbdf2c0, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvLight {
  AvLight() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb67002f6c8e6813, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadgetTextureInfo {
  AvGadgetTextureInfo() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f2cfde5589c790d1, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvVisualFrame {
  AvVisualFrame() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c63d22eedfe945e3, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvFrameListener {
  AvFrameListener() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct NewFrameParams;
  struct NewFrameResults;
  struct SendHapticEventParams;
  struct SendHapticEventResults;
  struct GrabEventParams;
  struct GrabEventResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(8015c5a053ba10f7)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct AvFrameListener::NewFrameParams {
  NewFrameParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb0fc7ad8b5a13e0, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvFrameListener::NewFrameResults {
  NewFrameResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb7ed1098aa53774, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvFrameListener::SendHapticEventParams {
  SendHapticEventParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8bba34fae0ebb16d, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvFrameListener::SendHapticEventResults {
  SendHapticEventResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e10179e87d664294, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvFrameListener::GrabEventParams {
  GrabEventParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(936192ac58f1de7e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvFrameListener::GrabEventResults {
  GrabEventResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dcaa723e1ce3648b, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvPanelProximity {
  AvPanelProximity() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(af5b8ea815d4c48a, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvPokerProcessor {
  AvPokerProcessor() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct UpdatePanelProximityParams;
  struct UpdatePanelProximityResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(e6824aebf526d4e8)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct AvPokerProcessor::UpdatePanelProximityParams {
  UpdatePanelProximityParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ea5196d27e4e0492, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvPokerProcessor::UpdatePanelProximityResults {
  UpdatePanelProximityResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab769bf8457ea26d, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvPanelMouseEvent {
  AvPanelMouseEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_e60de5b22d11d2d0 Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e865e502fce885ec, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvPanelProcessor {
  AvPanelProcessor() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct MouseEventParams;
  struct MouseEventResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(e829b4bc9d70eb7e)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct AvPanelProcessor::MouseEventParams {
  MouseEventParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cdfe97b4cee53bb9, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvPanelProcessor::MouseEventResults {
  MouseEventResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffd2e84ee76e83ba, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGrabberProcessor {
  AvGrabberProcessor() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct UpdateGrabberIntersectionsParams;
  struct UpdateGrabberIntersectionsResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ff3efec28716255a)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct AvGrabberProcessor::UpdateGrabberIntersectionsParams {
  UpdateGrabberIntersectionsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da268697d5366153, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGrabberProcessor::UpdateGrabberIntersectionsResults {
  UpdateGrabberIntersectionsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee91b214c65dd724, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGrabEvent {
  AvGrabEvent() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_f5cccdbd92cd311a Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(81074db71ab98254, 4, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGrabbableProcessor {
  AvGrabbableProcessor() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct GrabEventParams;
  struct GrabEventResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(bb3e161d2679685d)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct AvGrabbableProcessor::GrabEventParams {
  GrabEventParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e12cca80f5108a39, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGrabbableProcessor::GrabEventResults {
  GrabEventResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c9c7fc9085d51acf, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvVolume {
  AvVolume() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_c573c27aa036b25f Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff2e95d815609365, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvNode {
  AvNode() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_d941283d2e432ce6 Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cef52746090f960e, 2, 8)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvNodeWrapper {
  AvNodeWrapper() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f1e09ba70d4ac430, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvNodeRoot {
  AvNodeRoot() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cfe9abb40aa7aea4, 1, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer {
  AvServer() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct CreateGadgetParams;
  struct CreateGadgetResults;
  struct ListenForFramesParams;
  struct ListenForFramesResults;
  struct UpdateDxgiTextureForGadgetsParams;
  struct UpdateDxgiTextureForGadgetsResults;
  struct PushPokerProximityParams;
  struct PushPokerProximityResults;
  struct PushGrabIntersectionsParams;
  struct PushGrabIntersectionsResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(b8373e593ee6b1da)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct AvServer::CreateGadgetParams {
  CreateGadgetParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc8472282d3a40fb, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer::CreateGadgetResults {
  CreateGadgetResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8a66d1ef1c56b84f, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer::ListenForFramesParams {
  ListenForFramesParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fc31dffeb8e8c3d2, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer::ListenForFramesResults {
  ListenForFramesResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa2e11af02f503a9, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer::UpdateDxgiTextureForGadgetsParams {
  UpdateDxgiTextureForGadgetsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8939659054774402, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer::UpdateDxgiTextureForGadgetsResults {
  UpdateDxgiTextureForGadgetsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9e343036c482ec1, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer::PushPokerProximityParams {
  PushPokerProximityParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(de8c49e5e60c78ec, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer::PushPokerProximityResults {
  PushPokerProximityResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9349631ab9cbcbb2, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer::PushGrabIntersectionsParams {
  PushGrabIntersectionsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c9957ef3f1a43b2c, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvServer::PushGrabIntersectionsResults {
  PushGrabIntersectionsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fdaa564f79a910e9, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget {
  AvGadget() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct NameParams;
  struct NameResults;
  struct DestroyParams;
  struct DestroyResults;
  struct UpdateSceneGraphParams;
  struct UpdateSceneGraphResults;
  struct PushMouseEventParams;
  struct PushMouseEventResults;
  struct SendHapticEventParams;
  struct SendHapticEventResults;
  struct PushGrabEventParams;
  struct PushGrabEventResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(dcfdc1bffab9884a)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct AvGadget::NameParams {
  NameParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd6a0991599662d5, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::NameResults {
  NameResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd4d9d4d3811d454, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::DestroyParams {
  DestroyParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6bbdabf4790a569, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::DestroyResults {
  DestroyResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0281ad040f44f24, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::UpdateSceneGraphParams {
  UpdateSceneGraphParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cadd7a2e60f68024, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::UpdateSceneGraphResults {
  UpdateSceneGraphResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bce429661ca5e624, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::PushMouseEventParams {
  PushMouseEventParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d6a50fd325ec3b67, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::PushMouseEventResults {
  PushMouseEventResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a1fc6551ff04f7cf, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::SendHapticEventParams {
  SendHapticEventParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d301ea879688a412, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::SendHapticEventResults {
  SendHapticEventResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a87ef5a02cc9f0ab, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::PushGrabEventParams {
  PushGrabEventParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fc853a643c028139, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AvGadget::PushGrabEventResults {
  PushGrabEventResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac22fff5a9e71b08, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class AvSharedTextureInfo::Reader {
public:
  typedef AvSharedTextureInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::AvSharedTextureInfo::Type getType() const;

  inline  ::AvSharedTextureInfo::Format getFormat() const;

  inline  ::uint32_t getWidth() const;

  inline  ::uint32_t getHeight() const;

  inline  ::uint64_t getSharedTextureHandle() const;

  inline bool getInvertY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvSharedTextureInfo::Builder {
public:
  typedef AvSharedTextureInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::AvSharedTextureInfo::Type getType();
  inline void setType( ::AvSharedTextureInfo::Type value);

  inline  ::AvSharedTextureInfo::Format getFormat();
  inline void setFormat( ::AvSharedTextureInfo::Format value);

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline  ::uint32_t getHeight();
  inline void setHeight( ::uint32_t value);

  inline  ::uint64_t getSharedTextureHandle();
  inline void setSharedTextureHandle( ::uint64_t value);

  inline bool getInvertY();
  inline void setInvertY(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvSharedTextureInfo::Pipeline {
public:
  typedef AvSharedTextureInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvVector::Reader {
public:
  typedef AvVector Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvVector::Builder {
public:
  typedef AvVector Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvVector::Pipeline {
public:
  typedef AvVector Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvColor::Reader {
public:
  typedef AvColor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getR() const;

  inline float getG() const;

  inline float getB() const;

  inline float getA() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvColor::Builder {
public:
  typedef AvColor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getR();
  inline void setR(float value);

  inline float getG();
  inline void setG(float value);

  inline float getB();
  inline void setB(float value);

  inline float getA();
  inline void setA(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvColor::Pipeline {
public:
  typedef AvColor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvQuaternion::Reader {
public:
  typedef AvQuaternion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

  inline float getW() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvQuaternion::Builder {
public:
  typedef AvQuaternion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

  inline float getW();
  inline void setW(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvQuaternion::Pipeline {
public:
  typedef AvQuaternion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvTransform::Reader {
public:
  typedef AvTransform Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AvVector::Reader getPosition() const;

  inline bool hasRotation() const;
  inline  ::AvQuaternion::Reader getRotation() const;

  inline bool hasScale() const;
  inline  ::AvVector::Reader getScale() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvTransform::Builder {
public:
  typedef AvTransform Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AvVector::Builder getPosition();
  inline void setPosition( ::AvVector::Reader value);
  inline  ::AvVector::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AvVector>&& value);
  inline ::capnp::Orphan< ::AvVector> disownPosition();

  inline bool hasRotation();
  inline  ::AvQuaternion::Builder getRotation();
  inline void setRotation( ::AvQuaternion::Reader value);
  inline  ::AvQuaternion::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::AvQuaternion>&& value);
  inline ::capnp::Orphan< ::AvQuaternion> disownRotation();

  inline bool hasScale();
  inline  ::AvVector::Builder getScale();
  inline void setScale( ::AvVector::Reader value);
  inline  ::AvVector::Builder initScale();
  inline void adoptScale(::capnp::Orphan< ::AvVector>&& value);
  inline ::capnp::Orphan< ::AvVector> disownScale();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvTransform::Pipeline {
public:
  typedef AvTransform Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvVector::Pipeline getPosition();
  inline  ::AvQuaternion::Pipeline getRotation();
  inline  ::AvVector::Pipeline getScale();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvLight::Reader {
public:
  typedef AvLight Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTransform() const;
  inline  ::AvTransform::Reader getTransform() const;

  inline bool hasDiffuse() const;
  inline  ::AvColor::Reader getDiffuse() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvLight::Builder {
public:
  typedef AvLight Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTransform();
  inline  ::AvTransform::Builder getTransform();
  inline void setTransform( ::AvTransform::Reader value);
  inline  ::AvTransform::Builder initTransform();
  inline void adoptTransform(::capnp::Orphan< ::AvTransform>&& value);
  inline ::capnp::Orphan< ::AvTransform> disownTransform();

  inline bool hasDiffuse();
  inline  ::AvColor::Builder getDiffuse();
  inline void setDiffuse( ::AvColor::Reader value);
  inline  ::AvColor::Builder initDiffuse();
  inline void adoptDiffuse(::capnp::Orphan< ::AvColor>&& value);
  inline ::capnp::Orphan< ::AvColor> disownDiffuse();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvLight::Pipeline {
public:
  typedef AvLight Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvTransform::Pipeline getTransform();
  inline  ::AvColor::Pipeline getDiffuse();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadgetTextureInfo::Reader {
public:
  typedef AvGadgetTextureInfo Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGadgetName() const;
  inline  ::capnp::Text::Reader getGadgetName() const;

  inline  ::uint32_t getGadgetId() const;

  inline bool hasSharedTextureInfo() const;
  inline  ::AvSharedTextureInfo::Reader getSharedTextureInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadgetTextureInfo::Builder {
public:
  typedef AvGadgetTextureInfo Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGadgetName();
  inline  ::capnp::Text::Builder getGadgetName();
  inline void setGadgetName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGadgetName(unsigned int size);
  inline void adoptGadgetName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGadgetName();

  inline  ::uint32_t getGadgetId();
  inline void setGadgetId( ::uint32_t value);

  inline bool hasSharedTextureInfo();
  inline  ::AvSharedTextureInfo::Builder getSharedTextureInfo();
  inline void setSharedTextureInfo( ::AvSharedTextureInfo::Reader value);
  inline  ::AvSharedTextureInfo::Builder initSharedTextureInfo();
  inline void adoptSharedTextureInfo(::capnp::Orphan< ::AvSharedTextureInfo>&& value);
  inline ::capnp::Orphan< ::AvSharedTextureInfo> disownSharedTextureInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadgetTextureInfo::Pipeline {
public:
  typedef AvGadgetTextureInfo Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvSharedTextureInfo::Pipeline getSharedTextureInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvVisualFrame::Reader {
public:
  typedef AvVisualFrame Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId() const;

  inline bool hasRoots() const;
  inline  ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>::Reader getRoots() const;

  inline bool hasGadgetTextures() const;
  inline  ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>::Reader getGadgetTextures() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvVisualFrame::Builder {
public:
  typedef AvVisualFrame Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasRoots();
  inline  ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>::Builder getRoots();
  inline void setRoots( ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>::Builder initRoots(unsigned int size);
  inline void adoptRoots(::capnp::Orphan< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>> disownRoots();

  inline bool hasGadgetTextures();
  inline  ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>::Builder getGadgetTextures();
  inline void setGadgetTextures( ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>::Builder initGadgetTextures(unsigned int size);
  inline void adoptGadgetTextures(::capnp::Orphan< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>> disownGadgetTextures();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvVisualFrame::Pipeline {
public:
  typedef AvVisualFrame Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class AvFrameListener::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef AvFrameListener Calls;
  typedef AvFrameListener Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::AvFrameListener::NewFrameParams,  ::AvFrameListener::NewFrameResults> newFrameRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvFrameListener::SendHapticEventParams,  ::AvFrameListener::SendHapticEventResults> sendHapticEventRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvFrameListener::GrabEventParams,  ::AvFrameListener::GrabEventResults> grabEventRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class AvFrameListener::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef AvFrameListener Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::AvFrameListener::NewFrameParams NewFrameParams;
  typedef  ::AvFrameListener::NewFrameResults NewFrameResults;
  typedef ::capnp::CallContext<NewFrameParams, NewFrameResults> NewFrameContext;
  virtual ::kj::Promise<void> newFrame(NewFrameContext context);
  typedef  ::AvFrameListener::SendHapticEventParams SendHapticEventParams;
  typedef  ::AvFrameListener::SendHapticEventResults SendHapticEventResults;
  typedef ::capnp::CallContext<SendHapticEventParams, SendHapticEventResults> SendHapticEventContext;
  virtual ::kj::Promise<void> sendHapticEvent(SendHapticEventContext context);
  typedef  ::AvFrameListener::GrabEventParams GrabEventParams;
  typedef  ::AvFrameListener::GrabEventResults GrabEventResults;
  typedef ::capnp::CallContext<GrabEventParams, GrabEventResults> GrabEventContext;
  virtual ::kj::Promise<void> grabEvent(GrabEventContext context);

  inline  ::AvFrameListener::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::AvFrameListener>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class AvFrameListener::NewFrameParams::Reader {
public:
  typedef NewFrameParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFrame() const;
  inline  ::AvVisualFrame::Reader getFrame() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvFrameListener::NewFrameParams::Builder {
public:
  typedef NewFrameParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFrame();
  inline  ::AvVisualFrame::Builder getFrame();
  inline void setFrame( ::AvVisualFrame::Reader value);
  inline  ::AvVisualFrame::Builder initFrame();
  inline void adoptFrame(::capnp::Orphan< ::AvVisualFrame>&& value);
  inline ::capnp::Orphan< ::AvVisualFrame> disownFrame();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvFrameListener::NewFrameParams::Pipeline {
public:
  typedef NewFrameParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvVisualFrame::Pipeline getFrame();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvFrameListener::NewFrameResults::Reader {
public:
  typedef NewFrameResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvFrameListener::NewFrameResults::Builder {
public:
  typedef NewFrameResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvFrameListener::NewFrameResults::Pipeline {
public:
  typedef NewFrameResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvFrameListener::SendHapticEventParams::Reader {
public:
  typedef SendHapticEventParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTargetGlobalId() const;

  inline float getAmplitude() const;

  inline float getFrequency() const;

  inline float getDuration() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvFrameListener::SendHapticEventParams::Builder {
public:
  typedef SendHapticEventParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getTargetGlobalId();
  inline void setTargetGlobalId( ::uint64_t value);

  inline float getAmplitude();
  inline void setAmplitude(float value);

  inline float getFrequency();
  inline void setFrequency(float value);

  inline float getDuration();
  inline void setDuration(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvFrameListener::SendHapticEventParams::Pipeline {
public:
  typedef SendHapticEventParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvFrameListener::SendHapticEventResults::Reader {
public:
  typedef SendHapticEventResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvFrameListener::SendHapticEventResults::Builder {
public:
  typedef SendHapticEventResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvFrameListener::SendHapticEventResults::Pipeline {
public:
  typedef SendHapticEventResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvFrameListener::GrabEventParams::Reader {
public:
  typedef GrabEventParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEvent() const;
  inline  ::AvGrabEvent::Reader getEvent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvFrameListener::GrabEventParams::Builder {
public:
  typedef GrabEventParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEvent();
  inline  ::AvGrabEvent::Builder getEvent();
  inline void setEvent( ::AvGrabEvent::Reader value);
  inline  ::AvGrabEvent::Builder initEvent();
  inline void adoptEvent(::capnp::Orphan< ::AvGrabEvent>&& value);
  inline ::capnp::Orphan< ::AvGrabEvent> disownEvent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvFrameListener::GrabEventParams::Pipeline {
public:
  typedef GrabEventParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvGrabEvent::Pipeline getEvent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvFrameListener::GrabEventResults::Reader {
public:
  typedef GrabEventResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvFrameListener::GrabEventResults::Builder {
public:
  typedef GrabEventResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvFrameListener::GrabEventResults::Pipeline {
public:
  typedef GrabEventResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvPanelProximity::Reader {
public:
  typedef AvPanelProximity Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getPanelId() const;

  inline float getX() const;

  inline float getY() const;

  inline float getDistance() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvPanelProximity::Builder {
public:
  typedef AvPanelProximity Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getPanelId();
  inline void setPanelId( ::uint64_t value);

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getDistance();
  inline void setDistance(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvPanelProximity::Pipeline {
public:
  typedef AvPanelProximity Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class AvPokerProcessor::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef AvPokerProcessor Calls;
  typedef AvPokerProcessor Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::AvPokerProcessor::UpdatePanelProximityParams,  ::AvPokerProcessor::UpdatePanelProximityResults> updatePanelProximityRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class AvPokerProcessor::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef AvPokerProcessor Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::AvPokerProcessor::UpdatePanelProximityParams UpdatePanelProximityParams;
  typedef  ::AvPokerProcessor::UpdatePanelProximityResults UpdatePanelProximityResults;
  typedef ::capnp::CallContext<UpdatePanelProximityParams, UpdatePanelProximityResults> UpdatePanelProximityContext;
  virtual ::kj::Promise<void> updatePanelProximity(UpdatePanelProximityContext context);

  inline  ::AvPokerProcessor::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::AvPokerProcessor>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class AvPokerProcessor::UpdatePanelProximityParams::Reader {
public:
  typedef UpdatePanelProximityParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPokerId() const;

  inline bool hasProximity() const;
  inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Reader getProximity() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvPokerProcessor::UpdatePanelProximityParams::Builder {
public:
  typedef UpdatePanelProximityParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPokerId();
  inline void setPokerId( ::uint32_t value);

  inline bool hasProximity();
  inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Builder getProximity();
  inline void setProximity( ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Builder initProximity(unsigned int size);
  inline void adoptProximity(::capnp::Orphan< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>> disownProximity();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvPokerProcessor::UpdatePanelProximityParams::Pipeline {
public:
  typedef UpdatePanelProximityParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvPokerProcessor::UpdatePanelProximityResults::Reader {
public:
  typedef UpdatePanelProximityResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvPokerProcessor::UpdatePanelProximityResults::Builder {
public:
  typedef UpdatePanelProximityResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvPokerProcessor::UpdatePanelProximityResults::Pipeline {
public:
  typedef UpdatePanelProximityResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvPanelMouseEvent::Reader {
public:
  typedef AvPanelMouseEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::AvPanelMouseEvent::Type getType() const;

  inline  ::uint64_t getPanelId() const;

  inline  ::uint64_t getPokerId() const;

  inline float getX() const;

  inline float getY() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvPanelMouseEvent::Builder {
public:
  typedef AvPanelMouseEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::AvPanelMouseEvent::Type getType();
  inline void setType( ::AvPanelMouseEvent::Type value);

  inline  ::uint64_t getPanelId();
  inline void setPanelId( ::uint64_t value);

  inline  ::uint64_t getPokerId();
  inline void setPokerId( ::uint64_t value);

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvPanelMouseEvent::Pipeline {
public:
  typedef AvPanelMouseEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class AvPanelProcessor::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef AvPanelProcessor Calls;
  typedef AvPanelProcessor Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::AvPanelProcessor::MouseEventParams,  ::AvPanelProcessor::MouseEventResults> mouseEventRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class AvPanelProcessor::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef AvPanelProcessor Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::AvPanelProcessor::MouseEventParams MouseEventParams;
  typedef  ::AvPanelProcessor::MouseEventResults MouseEventResults;
  typedef ::capnp::CallContext<MouseEventParams, MouseEventResults> MouseEventContext;
  virtual ::kj::Promise<void> mouseEvent(MouseEventContext context);

  inline  ::AvPanelProcessor::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::AvPanelProcessor>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class AvPanelProcessor::MouseEventParams::Reader {
public:
  typedef MouseEventParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPanelId() const;

  inline bool hasEvent() const;
  inline  ::AvPanelMouseEvent::Reader getEvent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvPanelProcessor::MouseEventParams::Builder {
public:
  typedef MouseEventParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPanelId();
  inline void setPanelId( ::uint32_t value);

  inline bool hasEvent();
  inline  ::AvPanelMouseEvent::Builder getEvent();
  inline void setEvent( ::AvPanelMouseEvent::Reader value);
  inline  ::AvPanelMouseEvent::Builder initEvent();
  inline void adoptEvent(::capnp::Orphan< ::AvPanelMouseEvent>&& value);
  inline ::capnp::Orphan< ::AvPanelMouseEvent> disownEvent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvPanelProcessor::MouseEventParams::Pipeline {
public:
  typedef MouseEventParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvPanelMouseEvent::Pipeline getEvent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvPanelProcessor::MouseEventResults::Reader {
public:
  typedef MouseEventResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvPanelProcessor::MouseEventResults::Builder {
public:
  typedef MouseEventResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvPanelProcessor::MouseEventResults::Pipeline {
public:
  typedef MouseEventResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class AvGrabberProcessor::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef AvGrabberProcessor Calls;
  typedef AvGrabberProcessor Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::AvGrabberProcessor::UpdateGrabberIntersectionsParams,  ::AvGrabberProcessor::UpdateGrabberIntersectionsResults> updateGrabberIntersectionsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class AvGrabberProcessor::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef AvGrabberProcessor Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::AvGrabberProcessor::UpdateGrabberIntersectionsParams UpdateGrabberIntersectionsParams;
  typedef  ::AvGrabberProcessor::UpdateGrabberIntersectionsResults UpdateGrabberIntersectionsResults;
  typedef ::capnp::CallContext<UpdateGrabberIntersectionsParams, UpdateGrabberIntersectionsResults> UpdateGrabberIntersectionsContext;
  virtual ::kj::Promise<void> updateGrabberIntersections(UpdateGrabberIntersectionsContext context);

  inline  ::AvGrabberProcessor::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::AvGrabberProcessor>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class AvGrabberProcessor::UpdateGrabberIntersectionsParams::Reader {
public:
  typedef UpdateGrabberIntersectionsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getGrabberId() const;

  inline bool getGrabPressed() const;

  inline bool hasIntersections() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getIntersections() const;

  inline bool hasHooks() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getHooks() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder {
public:
  typedef UpdateGrabberIntersectionsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getGrabberId();
  inline void setGrabberId( ::uint32_t value);

  inline bool getGrabPressed();
  inline void setGrabPressed(bool value);

  inline bool hasIntersections();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getIntersections();
  inline void setIntersections( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setIntersections(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initIntersections(unsigned int size);
  inline void adoptIntersections(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownIntersections();

  inline bool hasHooks();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getHooks();
  inline void setHooks( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setHooks(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initHooks(unsigned int size);
  inline void adoptHooks(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownHooks();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGrabberProcessor::UpdateGrabberIntersectionsParams::Pipeline {
public:
  typedef UpdateGrabberIntersectionsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGrabberProcessor::UpdateGrabberIntersectionsResults::Reader {
public:
  typedef UpdateGrabberIntersectionsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGrabberProcessor::UpdateGrabberIntersectionsResults::Builder {
public:
  typedef UpdateGrabberIntersectionsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGrabberProcessor::UpdateGrabberIntersectionsResults::Pipeline {
public:
  typedef UpdateGrabberIntersectionsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGrabEvent::Reader {
public:
  typedef AvGrabEvent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::AvGrabEvent::Type getType() const;

  inline  ::uint64_t getGrabbableId() const;

  inline  ::uint64_t getGrabberId() const;

  inline  ::uint64_t getHookId() const;

  inline bool hasTransform() const;
  inline  ::AvTransform::Reader getTransform() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGrabEvent::Builder {
public:
  typedef AvGrabEvent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::AvGrabEvent::Type getType();
  inline void setType( ::AvGrabEvent::Type value);

  inline  ::uint64_t getGrabbableId();
  inline void setGrabbableId( ::uint64_t value);

  inline  ::uint64_t getGrabberId();
  inline void setGrabberId( ::uint64_t value);

  inline  ::uint64_t getHookId();
  inline void setHookId( ::uint64_t value);

  inline bool hasTransform();
  inline  ::AvTransform::Builder getTransform();
  inline void setTransform( ::AvTransform::Reader value);
  inline  ::AvTransform::Builder initTransform();
  inline void adoptTransform(::capnp::Orphan< ::AvTransform>&& value);
  inline ::capnp::Orphan< ::AvTransform> disownTransform();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGrabEvent::Pipeline {
public:
  typedef AvGrabEvent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvTransform::Pipeline getTransform();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class AvGrabbableProcessor::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef AvGrabbableProcessor Calls;
  typedef AvGrabbableProcessor Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::AvGrabbableProcessor::GrabEventParams,  ::AvGrabbableProcessor::GrabEventResults> grabEventRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class AvGrabbableProcessor::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef AvGrabbableProcessor Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::AvGrabbableProcessor::GrabEventParams GrabEventParams;
  typedef  ::AvGrabbableProcessor::GrabEventResults GrabEventResults;
  typedef ::capnp::CallContext<GrabEventParams, GrabEventResults> GrabEventContext;
  virtual ::kj::Promise<void> grabEvent(GrabEventContext context);

  inline  ::AvGrabbableProcessor::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::AvGrabbableProcessor>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class AvGrabbableProcessor::GrabEventParams::Reader {
public:
  typedef GrabEventParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getGrabbableId() const;

  inline bool hasEvent() const;
  inline  ::AvGrabEvent::Reader getEvent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGrabbableProcessor::GrabEventParams::Builder {
public:
  typedef GrabEventParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getGrabbableId();
  inline void setGrabbableId( ::uint32_t value);

  inline bool hasEvent();
  inline  ::AvGrabEvent::Builder getEvent();
  inline void setEvent( ::AvGrabEvent::Reader value);
  inline  ::AvGrabEvent::Builder initEvent();
  inline void adoptEvent(::capnp::Orphan< ::AvGrabEvent>&& value);
  inline ::capnp::Orphan< ::AvGrabEvent> disownEvent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGrabbableProcessor::GrabEventParams::Pipeline {
public:
  typedef GrabEventParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvGrabEvent::Pipeline getEvent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGrabbableProcessor::GrabEventResults::Reader {
public:
  typedef GrabEventResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGrabbableProcessor::GrabEventResults::Builder {
public:
  typedef GrabEventResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGrabbableProcessor::GrabEventResults::Pipeline {
public:
  typedef GrabEventResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvVolume::Reader {
public:
  typedef AvVolume Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::AvVolume::Type getType() const;

  inline float getRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvVolume::Builder {
public:
  typedef AvVolume Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::AvVolume::Type getType();
  inline void setType( ::AvVolume::Type value);

  inline float getRadius();
  inline void setRadius(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvVolume::Pipeline {
public:
  typedef AvVolume Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvNode::Reader {
public:
  typedef AvNode Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getId() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasChildren() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getChildren() const;

  inline  ::AvNode::Type getType() const;

  inline  ::uint32_t getFlags() const;

  inline bool hasPropOrigin() const;
  inline  ::capnp::Text::Reader getPropOrigin() const;

  inline bool hasPropTransform() const;
  inline  ::AvTransform::Reader getPropTransform() const;

  inline bool hasPropModelUri() const;
  inline  ::capnp::Text::Reader getPropModelUri() const;

  inline bool hasPropTextureSource() const;
  inline  ::capnp::Text::Reader getPropTextureSource() const;

  inline bool getPropInteractive() const;

  inline bool hasPropVolume() const;
  inline  ::AvVolume::Reader getPropVolume() const;

  inline bool hasPropCustomNodeType() const;
  inline  ::capnp::Text::Reader getPropCustomNodeType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvNode::Builder {
public:
  typedef AvNode Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getId();
  inline void setId( ::uint32_t value);

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasChildren();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getChildren();
  inline void setChildren( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setChildren(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initChildren(unsigned int size);
  inline void adoptChildren(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownChildren();

  inline  ::AvNode::Type getType();
  inline void setType( ::AvNode::Type value);

  inline  ::uint32_t getFlags();
  inline void setFlags( ::uint32_t value);

  inline bool hasPropOrigin();
  inline  ::capnp::Text::Builder getPropOrigin();
  inline void setPropOrigin( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPropOrigin(unsigned int size);
  inline void adoptPropOrigin(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPropOrigin();

  inline bool hasPropTransform();
  inline  ::AvTransform::Builder getPropTransform();
  inline void setPropTransform( ::AvTransform::Reader value);
  inline  ::AvTransform::Builder initPropTransform();
  inline void adoptPropTransform(::capnp::Orphan< ::AvTransform>&& value);
  inline ::capnp::Orphan< ::AvTransform> disownPropTransform();

  inline bool hasPropModelUri();
  inline  ::capnp::Text::Builder getPropModelUri();
  inline void setPropModelUri( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPropModelUri(unsigned int size);
  inline void adoptPropModelUri(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPropModelUri();

  inline bool hasPropTextureSource();
  inline  ::capnp::Text::Builder getPropTextureSource();
  inline void setPropTextureSource( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPropTextureSource(unsigned int size);
  inline void adoptPropTextureSource(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPropTextureSource();

  inline bool getPropInteractive();
  inline void setPropInteractive(bool value);

  inline bool hasPropVolume();
  inline  ::AvVolume::Builder getPropVolume();
  inline void setPropVolume( ::AvVolume::Reader value);
  inline  ::AvVolume::Builder initPropVolume();
  inline void adoptPropVolume(::capnp::Orphan< ::AvVolume>&& value);
  inline ::capnp::Orphan< ::AvVolume> disownPropVolume();

  inline bool hasPropCustomNodeType();
  inline  ::capnp::Text::Builder getPropCustomNodeType();
  inline void setPropCustomNodeType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPropCustomNodeType(unsigned int size);
  inline void adoptPropCustomNodeType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPropCustomNodeType();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvNode::Pipeline {
public:
  typedef AvNode Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvTransform::Pipeline getPropTransform();
  inline  ::AvVolume::Pipeline getPropVolume();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvNodeWrapper::Reader {
public:
  typedef AvNodeWrapper Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNode() const;
  inline  ::AvNode::Reader getNode() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvNodeWrapper::Builder {
public:
  typedef AvNodeWrapper Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNode();
  inline  ::AvNode::Builder getNode();
  inline void setNode( ::AvNode::Reader value);
  inline  ::AvNode::Builder initNode();
  inline void adoptNode(::capnp::Orphan< ::AvNode>&& value);
  inline ::capnp::Orphan< ::AvNode> disownNode();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvNodeWrapper::Pipeline {
public:
  typedef AvNodeWrapper Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvNode::Pipeline getNode();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvNodeRoot::Reader {
public:
  typedef AvNodeRoot Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNodes() const;
  inline  ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>::Reader getNodes() const;

  inline  ::uint32_t getSourceId() const;

  inline bool hasPokerProcessor() const;
#if !CAPNP_LITE
  inline  ::AvPokerProcessor::Client getPokerProcessor() const;
#endif  // !CAPNP_LITE

  inline bool hasPanelProcessor() const;
#if !CAPNP_LITE
  inline  ::AvPanelProcessor::Client getPanelProcessor() const;
#endif  // !CAPNP_LITE

  inline bool hasGrabberProcessor() const;
#if !CAPNP_LITE
  inline  ::AvGrabberProcessor::Client getGrabberProcessor() const;
#endif  // !CAPNP_LITE

  inline bool hasGrabbableProcessor() const;
#if !CAPNP_LITE
  inline  ::AvGrabbableProcessor::Client getGrabbableProcessor() const;
#endif  // !CAPNP_LITE

  inline bool hasHook() const;
  inline  ::capnp::Text::Reader getHook() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvNodeRoot::Builder {
public:
  typedef AvNodeRoot Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNodes();
  inline  ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>::Builder getNodes();
  inline void setNodes( ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>::Builder initNodes(unsigned int size);
  inline void adoptNodes(::capnp::Orphan< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>> disownNodes();

  inline  ::uint32_t getSourceId();
  inline void setSourceId( ::uint32_t value);

  inline bool hasPokerProcessor();
#if !CAPNP_LITE
  inline  ::AvPokerProcessor::Client getPokerProcessor();
  inline void setPokerProcessor( ::AvPokerProcessor::Client&& value);
  inline void setPokerProcessor( ::AvPokerProcessor::Client& value);
  inline void adoptPokerProcessor(::capnp::Orphan< ::AvPokerProcessor>&& value);
  inline ::capnp::Orphan< ::AvPokerProcessor> disownPokerProcessor();
#endif  // !CAPNP_LITE

  inline bool hasPanelProcessor();
#if !CAPNP_LITE
  inline  ::AvPanelProcessor::Client getPanelProcessor();
  inline void setPanelProcessor( ::AvPanelProcessor::Client&& value);
  inline void setPanelProcessor( ::AvPanelProcessor::Client& value);
  inline void adoptPanelProcessor(::capnp::Orphan< ::AvPanelProcessor>&& value);
  inline ::capnp::Orphan< ::AvPanelProcessor> disownPanelProcessor();
#endif  // !CAPNP_LITE

  inline bool hasGrabberProcessor();
#if !CAPNP_LITE
  inline  ::AvGrabberProcessor::Client getGrabberProcessor();
  inline void setGrabberProcessor( ::AvGrabberProcessor::Client&& value);
  inline void setGrabberProcessor( ::AvGrabberProcessor::Client& value);
  inline void adoptGrabberProcessor(::capnp::Orphan< ::AvGrabberProcessor>&& value);
  inline ::capnp::Orphan< ::AvGrabberProcessor> disownGrabberProcessor();
#endif  // !CAPNP_LITE

  inline bool hasGrabbableProcessor();
#if !CAPNP_LITE
  inline  ::AvGrabbableProcessor::Client getGrabbableProcessor();
  inline void setGrabbableProcessor( ::AvGrabbableProcessor::Client&& value);
  inline void setGrabbableProcessor( ::AvGrabbableProcessor::Client& value);
  inline void adoptGrabbableProcessor(::capnp::Orphan< ::AvGrabbableProcessor>&& value);
  inline ::capnp::Orphan< ::AvGrabbableProcessor> disownGrabbableProcessor();
#endif  // !CAPNP_LITE

  inline bool hasHook();
  inline  ::capnp::Text::Builder getHook();
  inline void setHook( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initHook(unsigned int size);
  inline void adoptHook(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownHook();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvNodeRoot::Pipeline {
public:
  typedef AvNodeRoot Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvPokerProcessor::Client getPokerProcessor();
  inline  ::AvPanelProcessor::Client getPanelProcessor();
  inline  ::AvGrabberProcessor::Client getGrabberProcessor();
  inline  ::AvGrabbableProcessor::Client getGrabbableProcessor();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class AvServer::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef AvServer Calls;
  typedef AvServer Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::AvServer::CreateGadgetParams,  ::AvServer::CreateGadgetResults> createGadgetRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvServer::ListenForFramesParams,  ::AvServer::ListenForFramesResults> listenForFramesRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvServer::UpdateDxgiTextureForGadgetsParams,  ::AvServer::UpdateDxgiTextureForGadgetsResults> updateDxgiTextureForGadgetsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvServer::PushPokerProximityParams,  ::AvServer::PushPokerProximityResults> pushPokerProximityRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvServer::PushGrabIntersectionsParams,  ::AvServer::PushGrabIntersectionsResults> pushGrabIntersectionsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class AvServer::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef AvServer Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::AvServer::CreateGadgetParams CreateGadgetParams;
  typedef  ::AvServer::CreateGadgetResults CreateGadgetResults;
  typedef ::capnp::CallContext<CreateGadgetParams, CreateGadgetResults> CreateGadgetContext;
  virtual ::kj::Promise<void> createGadget(CreateGadgetContext context);
  typedef  ::AvServer::ListenForFramesParams ListenForFramesParams;
  typedef  ::AvServer::ListenForFramesResults ListenForFramesResults;
  typedef ::capnp::CallContext<ListenForFramesParams, ListenForFramesResults> ListenForFramesContext;
  virtual ::kj::Promise<void> listenForFrames(ListenForFramesContext context);
  typedef  ::AvServer::UpdateDxgiTextureForGadgetsParams UpdateDxgiTextureForGadgetsParams;
  typedef  ::AvServer::UpdateDxgiTextureForGadgetsResults UpdateDxgiTextureForGadgetsResults;
  typedef ::capnp::CallContext<UpdateDxgiTextureForGadgetsParams, UpdateDxgiTextureForGadgetsResults> UpdateDxgiTextureForGadgetsContext;
  virtual ::kj::Promise<void> updateDxgiTextureForGadgets(UpdateDxgiTextureForGadgetsContext context);
  typedef  ::AvServer::PushPokerProximityParams PushPokerProximityParams;
  typedef  ::AvServer::PushPokerProximityResults PushPokerProximityResults;
  typedef ::capnp::CallContext<PushPokerProximityParams, PushPokerProximityResults> PushPokerProximityContext;
  virtual ::kj::Promise<void> pushPokerProximity(PushPokerProximityContext context);
  typedef  ::AvServer::PushGrabIntersectionsParams PushGrabIntersectionsParams;
  typedef  ::AvServer::PushGrabIntersectionsResults PushGrabIntersectionsResults;
  typedef ::capnp::CallContext<PushGrabIntersectionsParams, PushGrabIntersectionsResults> PushGrabIntersectionsContext;
  virtual ::kj::Promise<void> pushGrabIntersections(PushGrabIntersectionsContext context);

  inline  ::AvServer::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::AvServer>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class AvServer::CreateGadgetParams::Reader {
public:
  typedef CreateGadgetParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasInitialHook() const;
  inline  ::capnp::Text::Reader getInitialHook() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::CreateGadgetParams::Builder {
public:
  typedef CreateGadgetParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasInitialHook();
  inline  ::capnp::Text::Builder getInitialHook();
  inline void setInitialHook( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initInitialHook(unsigned int size);
  inline void adoptInitialHook(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownInitialHook();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::CreateGadgetParams::Pipeline {
public:
  typedef CreateGadgetParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvServer::CreateGadgetResults::Reader {
public:
  typedef CreateGadgetResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGadget() const;
#if !CAPNP_LITE
  inline  ::AvGadget::Client getGadget() const;
#endif  // !CAPNP_LITE

  inline  ::uint32_t getGadgetId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::CreateGadgetResults::Builder {
public:
  typedef CreateGadgetResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGadget();
#if !CAPNP_LITE
  inline  ::AvGadget::Client getGadget();
  inline void setGadget( ::AvGadget::Client&& value);
  inline void setGadget( ::AvGadget::Client& value);
  inline void adoptGadget(::capnp::Orphan< ::AvGadget>&& value);
  inline ::capnp::Orphan< ::AvGadget> disownGadget();
#endif  // !CAPNP_LITE

  inline  ::uint32_t getGadgetId();
  inline void setGadgetId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::CreateGadgetResults::Pipeline {
public:
  typedef CreateGadgetResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvGadget::Client getGadget();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvServer::ListenForFramesParams::Reader {
public:
  typedef ListenForFramesParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasListener() const;
#if !CAPNP_LITE
  inline  ::AvFrameListener::Client getListener() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::ListenForFramesParams::Builder {
public:
  typedef ListenForFramesParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasListener();
#if !CAPNP_LITE
  inline  ::AvFrameListener::Client getListener();
  inline void setListener( ::AvFrameListener::Client&& value);
  inline void setListener( ::AvFrameListener::Client& value);
  inline void adoptListener(::capnp::Orphan< ::AvFrameListener>&& value);
  inline ::capnp::Orphan< ::AvFrameListener> disownListener();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::ListenForFramesParams::Pipeline {
public:
  typedef ListenForFramesParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvFrameListener::Client getListener();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvServer::ListenForFramesResults::Reader {
public:
  typedef ListenForFramesResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::ListenForFramesResults::Builder {
public:
  typedef ListenForFramesResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::ListenForFramesResults::Pipeline {
public:
  typedef ListenForFramesResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvServer::UpdateDxgiTextureForGadgetsParams::Reader {
public:
  typedef UpdateDxgiTextureForGadgetsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGadgetIds() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getGadgetIds() const;

  inline bool hasSharedTextureInfo() const;
  inline  ::AvSharedTextureInfo::Reader getSharedTextureInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::UpdateDxgiTextureForGadgetsParams::Builder {
public:
  typedef UpdateDxgiTextureForGadgetsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGadgetIds();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getGadgetIds();
  inline void setGadgetIds( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setGadgetIds(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initGadgetIds(unsigned int size);
  inline void adoptGadgetIds(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownGadgetIds();

  inline bool hasSharedTextureInfo();
  inline  ::AvSharedTextureInfo::Builder getSharedTextureInfo();
  inline void setSharedTextureInfo( ::AvSharedTextureInfo::Reader value);
  inline  ::AvSharedTextureInfo::Builder initSharedTextureInfo();
  inline void adoptSharedTextureInfo(::capnp::Orphan< ::AvSharedTextureInfo>&& value);
  inline ::capnp::Orphan< ::AvSharedTextureInfo> disownSharedTextureInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::UpdateDxgiTextureForGadgetsParams::Pipeline {
public:
  typedef UpdateDxgiTextureForGadgetsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvSharedTextureInfo::Pipeline getSharedTextureInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvServer::UpdateDxgiTextureForGadgetsResults::Reader {
public:
  typedef UpdateDxgiTextureForGadgetsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::UpdateDxgiTextureForGadgetsResults::Builder {
public:
  typedef UpdateDxgiTextureForGadgetsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::UpdateDxgiTextureForGadgetsResults::Pipeline {
public:
  typedef UpdateDxgiTextureForGadgetsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvServer::PushPokerProximityParams::Reader {
public:
  typedef PushPokerProximityParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getPokerId() const;

  inline bool hasProximity() const;
  inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Reader getProximity() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::PushPokerProximityParams::Builder {
public:
  typedef PushPokerProximityParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getPokerId();
  inline void setPokerId( ::uint64_t value);

  inline bool hasProximity();
  inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Builder getProximity();
  inline void setProximity( ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Builder initProximity(unsigned int size);
  inline void adoptProximity(::capnp::Orphan< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>> disownProximity();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::PushPokerProximityParams::Pipeline {
public:
  typedef PushPokerProximityParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvServer::PushPokerProximityResults::Reader {
public:
  typedef PushPokerProximityResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::PushPokerProximityResults::Builder {
public:
  typedef PushPokerProximityResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::PushPokerProximityResults::Pipeline {
public:
  typedef PushPokerProximityResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvServer::PushGrabIntersectionsParams::Reader {
public:
  typedef PushGrabIntersectionsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getGrabberId() const;

  inline bool getIsGrabPressed() const;

  inline bool hasIntersections() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getIntersections() const;

  inline bool hasHooks() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getHooks() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::PushGrabIntersectionsParams::Builder {
public:
  typedef PushGrabIntersectionsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getGrabberId();
  inline void setGrabberId( ::uint64_t value);

  inline bool getIsGrabPressed();
  inline void setIsGrabPressed(bool value);

  inline bool hasIntersections();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getIntersections();
  inline void setIntersections( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setIntersections(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initIntersections(unsigned int size);
  inline void adoptIntersections(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownIntersections();

  inline bool hasHooks();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getHooks();
  inline void setHooks( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setHooks(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initHooks(unsigned int size);
  inline void adoptHooks(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownHooks();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::PushGrabIntersectionsParams::Pipeline {
public:
  typedef PushGrabIntersectionsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvServer::PushGrabIntersectionsResults::Reader {
public:
  typedef PushGrabIntersectionsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvServer::PushGrabIntersectionsResults::Builder {
public:
  typedef PushGrabIntersectionsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvServer::PushGrabIntersectionsResults::Pipeline {
public:
  typedef PushGrabIntersectionsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class AvGadget::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef AvGadget Calls;
  typedef AvGadget Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::AvGadget::NameParams,  ::AvGadget::NameResults> nameRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvGadget::DestroyParams,  ::AvGadget::DestroyResults> destroyRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvGadget::UpdateSceneGraphParams,  ::AvGadget::UpdateSceneGraphResults> updateSceneGraphRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvGadget::PushMouseEventParams,  ::AvGadget::PushMouseEventResults> pushMouseEventRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvGadget::SendHapticEventParams,  ::AvGadget::SendHapticEventResults> sendHapticEventRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::AvGadget::PushGrabEventParams,  ::AvGadget::PushGrabEventResults> pushGrabEventRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class AvGadget::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef AvGadget Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::AvGadget::NameParams NameParams;
  typedef  ::AvGadget::NameResults NameResults;
  typedef ::capnp::CallContext<NameParams, NameResults> NameContext;
  virtual ::kj::Promise<void> name(NameContext context);
  typedef  ::AvGadget::DestroyParams DestroyParams;
  typedef  ::AvGadget::DestroyResults DestroyResults;
  typedef ::capnp::CallContext<DestroyParams, DestroyResults> DestroyContext;
  virtual ::kj::Promise<void> destroy(DestroyContext context);
  typedef  ::AvGadget::UpdateSceneGraphParams UpdateSceneGraphParams;
  typedef  ::AvGadget::UpdateSceneGraphResults UpdateSceneGraphResults;
  typedef ::capnp::CallContext<UpdateSceneGraphParams, UpdateSceneGraphResults> UpdateSceneGraphContext;
  virtual ::kj::Promise<void> updateSceneGraph(UpdateSceneGraphContext context);
  typedef  ::AvGadget::PushMouseEventParams PushMouseEventParams;
  typedef  ::AvGadget::PushMouseEventResults PushMouseEventResults;
  typedef ::capnp::CallContext<PushMouseEventParams, PushMouseEventResults> PushMouseEventContext;
  virtual ::kj::Promise<void> pushMouseEvent(PushMouseEventContext context);
  typedef  ::AvGadget::SendHapticEventParams SendHapticEventParams;
  typedef  ::AvGadget::SendHapticEventResults SendHapticEventResults;
  typedef ::capnp::CallContext<SendHapticEventParams, SendHapticEventResults> SendHapticEventContext;
  virtual ::kj::Promise<void> sendHapticEvent(SendHapticEventContext context);
  typedef  ::AvGadget::PushGrabEventParams PushGrabEventParams;
  typedef  ::AvGadget::PushGrabEventResults PushGrabEventResults;
  typedef ::capnp::CallContext<PushGrabEventParams, PushGrabEventResults> PushGrabEventContext;
  virtual ::kj::Promise<void> pushGrabEvent(PushGrabEventContext context);

  inline  ::AvGadget::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::AvGadget>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class AvGadget::NameParams::Reader {
public:
  typedef NameParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::NameParams::Builder {
public:
  typedef NameParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::NameParams::Pipeline {
public:
  typedef NameParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::NameResults::Reader {
public:
  typedef NameResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::NameResults::Builder {
public:
  typedef NameResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::NameResults::Pipeline {
public:
  typedef NameResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::DestroyParams::Reader {
public:
  typedef DestroyParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::DestroyParams::Builder {
public:
  typedef DestroyParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::DestroyParams::Pipeline {
public:
  typedef DestroyParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::DestroyResults::Reader {
public:
  typedef DestroyResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::DestroyResults::Builder {
public:
  typedef DestroyResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::DestroyResults::Pipeline {
public:
  typedef DestroyResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::UpdateSceneGraphParams::Reader {
public:
  typedef UpdateSceneGraphParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRoot() const;
  inline  ::AvNodeRoot::Reader getRoot() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::UpdateSceneGraphParams::Builder {
public:
  typedef UpdateSceneGraphParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRoot();
  inline  ::AvNodeRoot::Builder getRoot();
  inline void setRoot( ::AvNodeRoot::Reader value);
  inline  ::AvNodeRoot::Builder initRoot();
  inline void adoptRoot(::capnp::Orphan< ::AvNodeRoot>&& value);
  inline ::capnp::Orphan< ::AvNodeRoot> disownRoot();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::UpdateSceneGraphParams::Pipeline {
public:
  typedef UpdateSceneGraphParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvNodeRoot::Pipeline getRoot();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::UpdateSceneGraphResults::Reader {
public:
  typedef UpdateSceneGraphResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getSuccess() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::UpdateSceneGraphResults::Builder {
public:
  typedef UpdateSceneGraphResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getSuccess();
  inline void setSuccess(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::UpdateSceneGraphResults::Pipeline {
public:
  typedef UpdateSceneGraphResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::PushMouseEventParams::Reader {
public:
  typedef PushMouseEventParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPokerNodeId() const;

  inline bool hasEvent() const;
  inline  ::AvPanelMouseEvent::Reader getEvent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::PushMouseEventParams::Builder {
public:
  typedef PushMouseEventParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getPokerNodeId();
  inline void setPokerNodeId( ::uint32_t value);

  inline bool hasEvent();
  inline  ::AvPanelMouseEvent::Builder getEvent();
  inline void setEvent( ::AvPanelMouseEvent::Reader value);
  inline  ::AvPanelMouseEvent::Builder initEvent();
  inline void adoptEvent(::capnp::Orphan< ::AvPanelMouseEvent>&& value);
  inline ::capnp::Orphan< ::AvPanelMouseEvent> disownEvent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::PushMouseEventParams::Pipeline {
public:
  typedef PushMouseEventParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvPanelMouseEvent::Pipeline getEvent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::PushMouseEventResults::Reader {
public:
  typedef PushMouseEventResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::PushMouseEventResults::Builder {
public:
  typedef PushMouseEventResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::PushMouseEventResults::Pipeline {
public:
  typedef PushMouseEventResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::SendHapticEventParams::Reader {
public:
  typedef SendHapticEventParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getNodeGlobalId() const;

  inline float getAmplitude() const;

  inline float getFrequency() const;

  inline float getDuration() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::SendHapticEventParams::Builder {
public:
  typedef SendHapticEventParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getNodeGlobalId();
  inline void setNodeGlobalId( ::uint64_t value);

  inline float getAmplitude();
  inline void setAmplitude(float value);

  inline float getFrequency();
  inline void setFrequency(float value);

  inline float getDuration();
  inline void setDuration(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::SendHapticEventParams::Pipeline {
public:
  typedef SendHapticEventParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::SendHapticEventResults::Reader {
public:
  typedef SendHapticEventResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::SendHapticEventResults::Builder {
public:
  typedef SendHapticEventResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::SendHapticEventResults::Pipeline {
public:
  typedef SendHapticEventResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::PushGrabEventParams::Reader {
public:
  typedef PushGrabEventParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getGrabberNodeId() const;

  inline bool hasEvent() const;
  inline  ::AvGrabEvent::Reader getEvent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::PushGrabEventParams::Builder {
public:
  typedef PushGrabEventParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getGrabberNodeId();
  inline void setGrabberNodeId( ::uint32_t value);

  inline bool hasEvent();
  inline  ::AvGrabEvent::Builder getEvent();
  inline void setEvent( ::AvGrabEvent::Reader value);
  inline  ::AvGrabEvent::Builder initEvent();
  inline void adoptEvent(::capnp::Orphan< ::AvGrabEvent>&& value);
  inline ::capnp::Orphan< ::AvGrabEvent> disownEvent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::PushGrabEventParams::Pipeline {
public:
  typedef PushGrabEventParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AvGrabEvent::Pipeline getEvent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AvGadget::PushGrabEventResults::Reader {
public:
  typedef PushGrabEventResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AvGadget::PushGrabEventResults::Builder {
public:
  typedef PushGrabEventResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AvGadget::PushGrabEventResults::Pipeline {
public:
  typedef PushGrabEventResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::AvSharedTextureInfo::Type AvSharedTextureInfo::Reader::getType() const {
  return _reader.getDataField< ::AvSharedTextureInfo::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::AvSharedTextureInfo::Type AvSharedTextureInfo::Builder::getType() {
  return _builder.getDataField< ::AvSharedTextureInfo::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvSharedTextureInfo::Builder::setType( ::AvSharedTextureInfo::Type value) {
  _builder.setDataField< ::AvSharedTextureInfo::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::AvSharedTextureInfo::Format AvSharedTextureInfo::Reader::getFormat() const {
  return _reader.getDataField< ::AvSharedTextureInfo::Format>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::AvSharedTextureInfo::Format AvSharedTextureInfo::Builder::getFormat() {
  return _builder.getDataField< ::AvSharedTextureInfo::Format>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AvSharedTextureInfo::Builder::setFormat( ::AvSharedTextureInfo::Format value) {
  _builder.setDataField< ::AvSharedTextureInfo::Format>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t AvSharedTextureInfo::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvSharedTextureInfo::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AvSharedTextureInfo::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t AvSharedTextureInfo::Reader::getHeight() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvSharedTextureInfo::Builder::getHeight() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvSharedTextureInfo::Builder::setHeight( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t AvSharedTextureInfo::Reader::getSharedTextureHandle() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvSharedTextureInfo::Builder::getSharedTextureHandle() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvSharedTextureInfo::Builder::setSharedTextureHandle( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool AvSharedTextureInfo::Reader::getInvertY() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS);
}

inline bool AvSharedTextureInfo::Builder::getInvertY() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS);
}
inline void AvSharedTextureInfo::Builder::setInvertY(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<96>() * ::capnp::ELEMENTS, value);
}

inline float AvVector::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float AvVector::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvVector::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float AvVector::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float AvVector::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AvVector::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float AvVector::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float AvVector::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvVector::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float AvColor::Reader::getR() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float AvColor::Builder::getR() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvColor::Builder::setR(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float AvColor::Reader::getG() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float AvColor::Builder::getG() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AvColor::Builder::setG(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float AvColor::Reader::getB() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float AvColor::Builder::getB() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvColor::Builder::setB(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float AvColor::Reader::getA() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float AvColor::Builder::getA() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void AvColor::Builder::setA(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float AvQuaternion::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float AvQuaternion::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvQuaternion::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float AvQuaternion::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float AvQuaternion::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AvQuaternion::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float AvQuaternion::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float AvQuaternion::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvQuaternion::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float AvQuaternion::Reader::getW() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float AvQuaternion::Builder::getW() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void AvQuaternion::Builder::setW(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool AvTransform::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvTransform::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvVector::Reader AvTransform::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AvVector>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvVector::Builder AvTransform::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AvVector>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvVector::Pipeline AvTransform::Pipeline::getPosition() {
  return  ::AvVector::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvTransform::Builder::setPosition( ::AvVector::Reader value) {
  ::capnp::_::PointerHelpers< ::AvVector>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvVector::Builder AvTransform::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AvVector>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvTransform::Builder::adoptPosition(
    ::capnp::Orphan< ::AvVector>&& value) {
  ::capnp::_::PointerHelpers< ::AvVector>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvVector> AvTransform::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AvVector>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvTransform::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvTransform::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::AvQuaternion::Reader AvTransform::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::AvQuaternion>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::AvQuaternion::Builder AvTransform::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::AvQuaternion>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvQuaternion::Pipeline AvTransform::Pipeline::getRotation() {
  return  ::AvQuaternion::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void AvTransform::Builder::setRotation( ::AvQuaternion::Reader value) {
  ::capnp::_::PointerHelpers< ::AvQuaternion>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::AvQuaternion::Builder AvTransform::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::AvQuaternion>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AvTransform::Builder::adoptRotation(
    ::capnp::Orphan< ::AvQuaternion>&& value) {
  ::capnp::_::PointerHelpers< ::AvQuaternion>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvQuaternion> AvTransform::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::AvQuaternion>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AvTransform::Reader::hasScale() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool AvTransform::Builder::hasScale() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::AvVector::Reader AvTransform::Reader::getScale() const {
  return ::capnp::_::PointerHelpers< ::AvVector>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::AvVector::Builder AvTransform::Builder::getScale() {
  return ::capnp::_::PointerHelpers< ::AvVector>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvVector::Pipeline AvTransform::Pipeline::getScale() {
  return  ::AvVector::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void AvTransform::Builder::setScale( ::AvVector::Reader value) {
  ::capnp::_::PointerHelpers< ::AvVector>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::AvVector::Builder AvTransform::Builder::initScale() {
  return ::capnp::_::PointerHelpers< ::AvVector>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void AvTransform::Builder::adoptScale(
    ::capnp::Orphan< ::AvVector>&& value) {
  ::capnp::_::PointerHelpers< ::AvVector>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvVector> AvTransform::Builder::disownScale() {
  return ::capnp::_::PointerHelpers< ::AvVector>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool AvLight::Reader::hasTransform() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvLight::Builder::hasTransform() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvTransform::Reader AvLight::Reader::getTransform() const {
  return ::capnp::_::PointerHelpers< ::AvTransform>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvTransform::Builder AvLight::Builder::getTransform() {
  return ::capnp::_::PointerHelpers< ::AvTransform>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvTransform::Pipeline AvLight::Pipeline::getTransform() {
  return  ::AvTransform::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvLight::Builder::setTransform( ::AvTransform::Reader value) {
  ::capnp::_::PointerHelpers< ::AvTransform>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvTransform::Builder AvLight::Builder::initTransform() {
  return ::capnp::_::PointerHelpers< ::AvTransform>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvLight::Builder::adoptTransform(
    ::capnp::Orphan< ::AvTransform>&& value) {
  ::capnp::_::PointerHelpers< ::AvTransform>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvTransform> AvLight::Builder::disownTransform() {
  return ::capnp::_::PointerHelpers< ::AvTransform>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvLight::Reader::hasDiffuse() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvLight::Builder::hasDiffuse() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::AvColor::Reader AvLight::Reader::getDiffuse() const {
  return ::capnp::_::PointerHelpers< ::AvColor>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::AvColor::Builder AvLight::Builder::getDiffuse() {
  return ::capnp::_::PointerHelpers< ::AvColor>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvColor::Pipeline AvLight::Pipeline::getDiffuse() {
  return  ::AvColor::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void AvLight::Builder::setDiffuse( ::AvColor::Reader value) {
  ::capnp::_::PointerHelpers< ::AvColor>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::AvColor::Builder AvLight::Builder::initDiffuse() {
  return ::capnp::_::PointerHelpers< ::AvColor>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AvLight::Builder::adoptDiffuse(
    ::capnp::Orphan< ::AvColor>&& value) {
  ::capnp::_::PointerHelpers< ::AvColor>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvColor> AvLight::Builder::disownDiffuse() {
  return ::capnp::_::PointerHelpers< ::AvColor>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AvGadgetTextureInfo::Reader::hasGadgetName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvGadgetTextureInfo::Builder::hasGadgetName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvGadgetTextureInfo::Reader::getGadgetName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvGadgetTextureInfo::Builder::getGadgetName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvGadgetTextureInfo::Builder::setGadgetName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvGadgetTextureInfo::Builder::initGadgetName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvGadgetTextureInfo::Builder::adoptGadgetName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvGadgetTextureInfo::Builder::disownGadgetName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t AvGadgetTextureInfo::Reader::getGadgetId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvGadgetTextureInfo::Builder::getGadgetId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvGadgetTextureInfo::Builder::setGadgetId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvGadgetTextureInfo::Reader::hasSharedTextureInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvGadgetTextureInfo::Builder::hasSharedTextureInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::AvSharedTextureInfo::Reader AvGadgetTextureInfo::Reader::getSharedTextureInfo() const {
  return ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::AvSharedTextureInfo::Builder AvGadgetTextureInfo::Builder::getSharedTextureInfo() {
  return ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvSharedTextureInfo::Pipeline AvGadgetTextureInfo::Pipeline::getSharedTextureInfo() {
  return  ::AvSharedTextureInfo::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void AvGadgetTextureInfo::Builder::setSharedTextureInfo( ::AvSharedTextureInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::AvSharedTextureInfo::Builder AvGadgetTextureInfo::Builder::initSharedTextureInfo() {
  return ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AvGadgetTextureInfo::Builder::adoptSharedTextureInfo(
    ::capnp::Orphan< ::AvSharedTextureInfo>&& value) {
  ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvSharedTextureInfo> AvGadgetTextureInfo::Builder::disownSharedTextureInfo() {
  return ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint64_t AvVisualFrame::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvVisualFrame::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvVisualFrame::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvVisualFrame::Reader::hasRoots() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvVisualFrame::Builder::hasRoots() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>::Reader AvVisualFrame::Reader::getRoots() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>::Builder AvVisualFrame::Builder::getRoots() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvVisualFrame::Builder::setRoots( ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>::Builder AvVisualFrame::Builder::initRoots(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvVisualFrame::Builder::adoptRoots(
    ::capnp::Orphan< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>> AvVisualFrame::Builder::disownRoots() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeRoot,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvVisualFrame::Reader::hasGadgetTextures() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvVisualFrame::Builder::hasGadgetTextures() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>::Reader AvVisualFrame::Reader::getGadgetTextures() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>::Builder AvVisualFrame::Builder::getGadgetTextures() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AvVisualFrame::Builder::setGadgetTextures( ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>::Builder AvVisualFrame::Builder::initGadgetTextures(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void AvVisualFrame::Builder::adoptGadgetTextures(
    ::capnp::Orphan< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>> AvVisualFrame::Builder::disownGadgetTextures() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvGadgetTextureInfo,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline AvFrameListener::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline AvFrameListener::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline AvFrameListener::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline AvFrameListener::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline AvFrameListener::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::AvFrameListener::Client& AvFrameListener::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::AvFrameListener::Client& AvFrameListener::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool AvFrameListener::NewFrameParams::Reader::hasFrame() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvFrameListener::NewFrameParams::Builder::hasFrame() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvVisualFrame::Reader AvFrameListener::NewFrameParams::Reader::getFrame() const {
  return ::capnp::_::PointerHelpers< ::AvVisualFrame>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvVisualFrame::Builder AvFrameListener::NewFrameParams::Builder::getFrame() {
  return ::capnp::_::PointerHelpers< ::AvVisualFrame>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvVisualFrame::Pipeline AvFrameListener::NewFrameParams::Pipeline::getFrame() {
  return  ::AvVisualFrame::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvFrameListener::NewFrameParams::Builder::setFrame( ::AvVisualFrame::Reader value) {
  ::capnp::_::PointerHelpers< ::AvVisualFrame>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvVisualFrame::Builder AvFrameListener::NewFrameParams::Builder::initFrame() {
  return ::capnp::_::PointerHelpers< ::AvVisualFrame>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvFrameListener::NewFrameParams::Builder::adoptFrame(
    ::capnp::Orphan< ::AvVisualFrame>&& value) {
  ::capnp::_::PointerHelpers< ::AvVisualFrame>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvVisualFrame> AvFrameListener::NewFrameParams::Builder::disownFrame() {
  return ::capnp::_::PointerHelpers< ::AvVisualFrame>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t AvFrameListener::SendHapticEventParams::Reader::getTargetGlobalId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvFrameListener::SendHapticEventParams::Builder::getTargetGlobalId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvFrameListener::SendHapticEventParams::Builder::setTargetGlobalId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float AvFrameListener::SendHapticEventParams::Reader::getAmplitude() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float AvFrameListener::SendHapticEventParams::Builder::getAmplitude() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvFrameListener::SendHapticEventParams::Builder::setAmplitude(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float AvFrameListener::SendHapticEventParams::Reader::getFrequency() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float AvFrameListener::SendHapticEventParams::Builder::getFrequency() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void AvFrameListener::SendHapticEventParams::Builder::setFrequency(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float AvFrameListener::SendHapticEventParams::Reader::getDuration() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float AvFrameListener::SendHapticEventParams::Builder::getDuration() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void AvFrameListener::SendHapticEventParams::Builder::setDuration(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool AvFrameListener::GrabEventParams::Reader::hasEvent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvFrameListener::GrabEventParams::Builder::hasEvent() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvGrabEvent::Reader AvFrameListener::GrabEventParams::Reader::getEvent() const {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvGrabEvent::Builder AvFrameListener::GrabEventParams::Builder::getEvent() {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvGrabEvent::Pipeline AvFrameListener::GrabEventParams::Pipeline::getEvent() {
  return  ::AvGrabEvent::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvFrameListener::GrabEventParams::Builder::setEvent( ::AvGrabEvent::Reader value) {
  ::capnp::_::PointerHelpers< ::AvGrabEvent>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvGrabEvent::Builder AvFrameListener::GrabEventParams::Builder::initEvent() {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvFrameListener::GrabEventParams::Builder::adoptEvent(
    ::capnp::Orphan< ::AvGrabEvent>&& value) {
  ::capnp::_::PointerHelpers< ::AvGrabEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvGrabEvent> AvFrameListener::GrabEventParams::Builder::disownEvent() {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t AvPanelProximity::Reader::getPanelId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvPanelProximity::Builder::getPanelId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvPanelProximity::Builder::setPanelId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float AvPanelProximity::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float AvPanelProximity::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvPanelProximity::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float AvPanelProximity::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float AvPanelProximity::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void AvPanelProximity::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float AvPanelProximity::Reader::getDistance() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float AvPanelProximity::Builder::getDistance() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void AvPanelProximity::Builder::setDistance(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline AvPokerProcessor::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline AvPokerProcessor::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline AvPokerProcessor::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline AvPokerProcessor::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline AvPokerProcessor::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::AvPokerProcessor::Client& AvPokerProcessor::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::AvPokerProcessor::Client& AvPokerProcessor::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint32_t AvPokerProcessor::UpdatePanelProximityParams::Reader::getPokerId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvPokerProcessor::UpdatePanelProximityParams::Builder::getPokerId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvPokerProcessor::UpdatePanelProximityParams::Builder::setPokerId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvPokerProcessor::UpdatePanelProximityParams::Reader::hasProximity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvPokerProcessor::UpdatePanelProximityParams::Builder::hasProximity() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Reader AvPokerProcessor::UpdatePanelProximityParams::Reader::getProximity() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Builder AvPokerProcessor::UpdatePanelProximityParams::Builder::getProximity() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvPokerProcessor::UpdatePanelProximityParams::Builder::setProximity( ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Builder AvPokerProcessor::UpdatePanelProximityParams::Builder::initProximity(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvPokerProcessor::UpdatePanelProximityParams::Builder::adoptProximity(
    ::capnp::Orphan< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>> AvPokerProcessor::UpdatePanelProximityParams::Builder::disownProximity() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::AvPanelMouseEvent::Type AvPanelMouseEvent::Reader::getType() const {
  return _reader.getDataField< ::AvPanelMouseEvent::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::AvPanelMouseEvent::Type AvPanelMouseEvent::Builder::getType() {
  return _builder.getDataField< ::AvPanelMouseEvent::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvPanelMouseEvent::Builder::setType( ::AvPanelMouseEvent::Type value) {
  _builder.setDataField< ::AvPanelMouseEvent::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t AvPanelMouseEvent::Reader::getPanelId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvPanelMouseEvent::Builder::getPanelId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AvPanelMouseEvent::Builder::setPanelId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t AvPanelMouseEvent::Reader::getPokerId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvPanelMouseEvent::Builder::getPokerId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvPanelMouseEvent::Builder::setPokerId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float AvPanelMouseEvent::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float AvPanelMouseEvent::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AvPanelMouseEvent::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float AvPanelMouseEvent::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float AvPanelMouseEvent::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void AvPanelMouseEvent::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline AvPanelProcessor::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline AvPanelProcessor::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline AvPanelProcessor::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline AvPanelProcessor::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline AvPanelProcessor::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::AvPanelProcessor::Client& AvPanelProcessor::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::AvPanelProcessor::Client& AvPanelProcessor::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint32_t AvPanelProcessor::MouseEventParams::Reader::getPanelId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvPanelProcessor::MouseEventParams::Builder::getPanelId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvPanelProcessor::MouseEventParams::Builder::setPanelId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvPanelProcessor::MouseEventParams::Reader::hasEvent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvPanelProcessor::MouseEventParams::Builder::hasEvent() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvPanelMouseEvent::Reader AvPanelProcessor::MouseEventParams::Reader::getEvent() const {
  return ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvPanelMouseEvent::Builder AvPanelProcessor::MouseEventParams::Builder::getEvent() {
  return ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvPanelMouseEvent::Pipeline AvPanelProcessor::MouseEventParams::Pipeline::getEvent() {
  return  ::AvPanelMouseEvent::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvPanelProcessor::MouseEventParams::Builder::setEvent( ::AvPanelMouseEvent::Reader value) {
  ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvPanelMouseEvent::Builder AvPanelProcessor::MouseEventParams::Builder::initEvent() {
  return ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvPanelProcessor::MouseEventParams::Builder::adoptEvent(
    ::capnp::Orphan< ::AvPanelMouseEvent>&& value) {
  ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvPanelMouseEvent> AvPanelProcessor::MouseEventParams::Builder::disownEvent() {
  return ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline AvGrabberProcessor::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline AvGrabberProcessor::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline AvGrabberProcessor::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline AvGrabberProcessor::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline AvGrabberProcessor::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::AvGrabberProcessor::Client& AvGrabberProcessor::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::AvGrabberProcessor::Client& AvGrabberProcessor::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint32_t AvGrabberProcessor::UpdateGrabberIntersectionsParams::Reader::getGrabberId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::getGrabberId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::setGrabberId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvGrabberProcessor::UpdateGrabberIntersectionsParams::Reader::getGrabPressed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::getGrabPressed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::setGrabPressed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool AvGrabberProcessor::UpdateGrabberIntersectionsParams::Reader::hasIntersections() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::hasIntersections() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader AvGrabberProcessor::UpdateGrabberIntersectionsParams::Reader::getIntersections() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::getIntersections() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::setIntersections( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::setIntersections(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::initIntersections(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::adoptIntersections(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::disownIntersections() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvGrabberProcessor::UpdateGrabberIntersectionsParams::Reader::hasHooks() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::hasHooks() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader AvGrabberProcessor::UpdateGrabberIntersectionsParams::Reader::getHooks() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::getHooks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::setHooks( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::setHooks(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::initHooks(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::adoptHooks(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> AvGrabberProcessor::UpdateGrabberIntersectionsParams::Builder::disownHooks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::AvGrabEvent::Type AvGrabEvent::Reader::getType() const {
  return _reader.getDataField< ::AvGrabEvent::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::AvGrabEvent::Type AvGrabEvent::Builder::getType() {
  return _builder.getDataField< ::AvGrabEvent::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvGrabEvent::Builder::setType( ::AvGrabEvent::Type value) {
  _builder.setDataField< ::AvGrabEvent::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t AvGrabEvent::Reader::getGrabbableId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvGrabEvent::Builder::getGrabbableId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AvGrabEvent::Builder::setGrabbableId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t AvGrabEvent::Reader::getGrabberId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvGrabEvent::Builder::getGrabberId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvGrabEvent::Builder::setGrabberId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t AvGrabEvent::Reader::getHookId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvGrabEvent::Builder::getHookId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void AvGrabEvent::Builder::setHookId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool AvGrabEvent::Reader::hasTransform() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvGrabEvent::Builder::hasTransform() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvTransform::Reader AvGrabEvent::Reader::getTransform() const {
  return ::capnp::_::PointerHelpers< ::AvTransform>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvTransform::Builder AvGrabEvent::Builder::getTransform() {
  return ::capnp::_::PointerHelpers< ::AvTransform>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvTransform::Pipeline AvGrabEvent::Pipeline::getTransform() {
  return  ::AvTransform::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvGrabEvent::Builder::setTransform( ::AvTransform::Reader value) {
  ::capnp::_::PointerHelpers< ::AvTransform>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvTransform::Builder AvGrabEvent::Builder::initTransform() {
  return ::capnp::_::PointerHelpers< ::AvTransform>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvGrabEvent::Builder::adoptTransform(
    ::capnp::Orphan< ::AvTransform>&& value) {
  ::capnp::_::PointerHelpers< ::AvTransform>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvTransform> AvGrabEvent::Builder::disownTransform() {
  return ::capnp::_::PointerHelpers< ::AvTransform>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline AvGrabbableProcessor::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline AvGrabbableProcessor::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline AvGrabbableProcessor::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline AvGrabbableProcessor::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline AvGrabbableProcessor::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::AvGrabbableProcessor::Client& AvGrabbableProcessor::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::AvGrabbableProcessor::Client& AvGrabbableProcessor::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint32_t AvGrabbableProcessor::GrabEventParams::Reader::getGrabbableId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvGrabbableProcessor::GrabEventParams::Builder::getGrabbableId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvGrabbableProcessor::GrabEventParams::Builder::setGrabbableId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvGrabbableProcessor::GrabEventParams::Reader::hasEvent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvGrabbableProcessor::GrabEventParams::Builder::hasEvent() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvGrabEvent::Reader AvGrabbableProcessor::GrabEventParams::Reader::getEvent() const {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvGrabEvent::Builder AvGrabbableProcessor::GrabEventParams::Builder::getEvent() {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvGrabEvent::Pipeline AvGrabbableProcessor::GrabEventParams::Pipeline::getEvent() {
  return  ::AvGrabEvent::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvGrabbableProcessor::GrabEventParams::Builder::setEvent( ::AvGrabEvent::Reader value) {
  ::capnp::_::PointerHelpers< ::AvGrabEvent>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvGrabEvent::Builder AvGrabbableProcessor::GrabEventParams::Builder::initEvent() {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvGrabbableProcessor::GrabEventParams::Builder::adoptEvent(
    ::capnp::Orphan< ::AvGrabEvent>&& value) {
  ::capnp::_::PointerHelpers< ::AvGrabEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvGrabEvent> AvGrabbableProcessor::GrabEventParams::Builder::disownEvent() {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::AvVolume::Type AvVolume::Reader::getType() const {
  return _reader.getDataField< ::AvVolume::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::AvVolume::Type AvVolume::Builder::getType() {
  return _builder.getDataField< ::AvVolume::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvVolume::Builder::setType( ::AvVolume::Type value) {
  _builder.setDataField< ::AvVolume::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float AvVolume::Reader::getRadius() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float AvVolume::Builder::getRadius() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AvVolume::Builder::setRadius(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t AvNode::Reader::getId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvNode::Builder::getId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvNode::Builder::setId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvNode::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvNode::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvNode::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvNode::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvNode::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvNode::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvNode::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvNode::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvNode::Reader::hasChildren() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvNode::Builder::hasChildren() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader AvNode::Reader::getChildren() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder AvNode::Builder::getChildren() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AvNode::Builder::setChildren( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void AvNode::Builder::setChildren(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder AvNode::Builder::initChildren(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void AvNode::Builder::adoptChildren(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> AvNode::Builder::disownChildren() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::AvNode::Type AvNode::Reader::getType() const {
  return _reader.getDataField< ::AvNode::Type>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::AvNode::Type AvNode::Builder::getType() {
  return _builder.getDataField< ::AvNode::Type>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvNode::Builder::setType( ::AvNode::Type value) {
  _builder.setDataField< ::AvNode::Type>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t AvNode::Reader::getFlags() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvNode::Builder::getFlags() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvNode::Builder::setFlags( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool AvNode::Reader::hasPropOrigin() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool AvNode::Builder::hasPropOrigin() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvNode::Reader::getPropOrigin() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvNode::Builder::getPropOrigin() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void AvNode::Builder::setPropOrigin( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvNode::Builder::initPropOrigin(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void AvNode::Builder::adoptPropOrigin(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvNode::Builder::disownPropOrigin() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool AvNode::Reader::hasPropTransform() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool AvNode::Builder::hasPropTransform() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::AvTransform::Reader AvNode::Reader::getPropTransform() const {
  return ::capnp::_::PointerHelpers< ::AvTransform>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::AvTransform::Builder AvNode::Builder::getPropTransform() {
  return ::capnp::_::PointerHelpers< ::AvTransform>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvTransform::Pipeline AvNode::Pipeline::getPropTransform() {
  return  ::AvTransform::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void AvNode::Builder::setPropTransform( ::AvTransform::Reader value) {
  ::capnp::_::PointerHelpers< ::AvTransform>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::AvTransform::Builder AvNode::Builder::initPropTransform() {
  return ::capnp::_::PointerHelpers< ::AvTransform>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void AvNode::Builder::adoptPropTransform(
    ::capnp::Orphan< ::AvTransform>&& value) {
  ::capnp::_::PointerHelpers< ::AvTransform>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvTransform> AvNode::Builder::disownPropTransform() {
  return ::capnp::_::PointerHelpers< ::AvTransform>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool AvNode::Reader::hasPropModelUri() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool AvNode::Builder::hasPropModelUri() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvNode::Reader::getPropModelUri() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvNode::Builder::getPropModelUri() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void AvNode::Builder::setPropModelUri( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvNode::Builder::initPropModelUri(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void AvNode::Builder::adoptPropModelUri(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvNode::Builder::disownPropModelUri() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool AvNode::Reader::hasPropTextureSource() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool AvNode::Builder::hasPropTextureSource() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvNode::Reader::getPropTextureSource() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvNode::Builder::getPropTextureSource() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void AvNode::Builder::setPropTextureSource( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvNode::Builder::initPropTextureSource(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void AvNode::Builder::adoptPropTextureSource(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvNode::Builder::disownPropTextureSource() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool AvNode::Reader::getPropInteractive() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<48>() * ::capnp::ELEMENTS);
}

inline bool AvNode::Builder::getPropInteractive() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<48>() * ::capnp::ELEMENTS);
}
inline void AvNode::Builder::setPropInteractive(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<48>() * ::capnp::ELEMENTS, value);
}

inline bool AvNode::Reader::hasPropVolume() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool AvNode::Builder::hasPropVolume() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::AvVolume::Reader AvNode::Reader::getPropVolume() const {
  return ::capnp::_::PointerHelpers< ::AvVolume>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::AvVolume::Builder AvNode::Builder::getPropVolume() {
  return ::capnp::_::PointerHelpers< ::AvVolume>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvVolume::Pipeline AvNode::Pipeline::getPropVolume() {
  return  ::AvVolume::Pipeline(_typeless.getPointerField(6));
}
#endif  // !CAPNP_LITE
inline void AvNode::Builder::setPropVolume( ::AvVolume::Reader value) {
  ::capnp::_::PointerHelpers< ::AvVolume>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::AvVolume::Builder AvNode::Builder::initPropVolume() {
  return ::capnp::_::PointerHelpers< ::AvVolume>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void AvNode::Builder::adoptPropVolume(
    ::capnp::Orphan< ::AvVolume>&& value) {
  ::capnp::_::PointerHelpers< ::AvVolume>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvVolume> AvNode::Builder::disownPropVolume() {
  return ::capnp::_::PointerHelpers< ::AvVolume>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool AvNode::Reader::hasPropCustomNodeType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool AvNode::Builder::hasPropCustomNodeType() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvNode::Reader::getPropCustomNodeType() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvNode::Builder::getPropCustomNodeType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void AvNode::Builder::setPropCustomNodeType( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvNode::Builder::initPropCustomNodeType(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), size);
}
inline void AvNode::Builder::adoptPropCustomNodeType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvNode::Builder::disownPropCustomNodeType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool AvNodeWrapper::Reader::hasNode() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvNodeWrapper::Builder::hasNode() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvNode::Reader AvNodeWrapper::Reader::getNode() const {
  return ::capnp::_::PointerHelpers< ::AvNode>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvNode::Builder AvNodeWrapper::Builder::getNode() {
  return ::capnp::_::PointerHelpers< ::AvNode>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvNode::Pipeline AvNodeWrapper::Pipeline::getNode() {
  return  ::AvNode::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvNodeWrapper::Builder::setNode( ::AvNode::Reader value) {
  ::capnp::_::PointerHelpers< ::AvNode>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvNode::Builder AvNodeWrapper::Builder::initNode() {
  return ::capnp::_::PointerHelpers< ::AvNode>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvNodeWrapper::Builder::adoptNode(
    ::capnp::Orphan< ::AvNode>&& value) {
  ::capnp::_::PointerHelpers< ::AvNode>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvNode> AvNodeWrapper::Builder::disownNode() {
  return ::capnp::_::PointerHelpers< ::AvNode>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvNodeRoot::Reader::hasNodes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvNodeRoot::Builder::hasNodes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>::Reader AvNodeRoot::Reader::getNodes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>::Builder AvNodeRoot::Builder::getNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvNodeRoot::Builder::setNodes( ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>::Builder AvNodeRoot::Builder::initNodes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvNodeRoot::Builder::adoptNodes(
    ::capnp::Orphan< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>> AvNodeRoot::Builder::disownNodes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvNodeWrapper,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t AvNodeRoot::Reader::getSourceId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvNodeRoot::Builder::getSourceId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvNodeRoot::Builder::setSourceId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvNodeRoot::Reader::hasPokerProcessor() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvNodeRoot::Builder::hasPokerProcessor() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::AvPokerProcessor::Client AvNodeRoot::Reader::getPokerProcessor() const {
  return ::capnp::_::PointerHelpers< ::AvPokerProcessor>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::AvPokerProcessor::Client AvNodeRoot::Builder::getPokerProcessor() {
  return ::capnp::_::PointerHelpers< ::AvPokerProcessor>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::AvPokerProcessor::Client AvNodeRoot::Pipeline::getPokerProcessor() {
  return  ::AvPokerProcessor::Client(_typeless.getPointerField(1).asCap());
}
inline void AvNodeRoot::Builder::setPokerProcessor( ::AvPokerProcessor::Client&& cap) {
  ::capnp::_::PointerHelpers< ::AvPokerProcessor>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AvNodeRoot::Builder::setPokerProcessor( ::AvPokerProcessor::Client& cap) {
  ::capnp::_::PointerHelpers< ::AvPokerProcessor>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void AvNodeRoot::Builder::adoptPokerProcessor(
    ::capnp::Orphan< ::AvPokerProcessor>&& value) {
  ::capnp::_::PointerHelpers< ::AvPokerProcessor>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvPokerProcessor> AvNodeRoot::Builder::disownPokerProcessor() {
  return ::capnp::_::PointerHelpers< ::AvPokerProcessor>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool AvNodeRoot::Reader::hasPanelProcessor() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool AvNodeRoot::Builder::hasPanelProcessor() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::AvPanelProcessor::Client AvNodeRoot::Reader::getPanelProcessor() const {
  return ::capnp::_::PointerHelpers< ::AvPanelProcessor>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::AvPanelProcessor::Client AvNodeRoot::Builder::getPanelProcessor() {
  return ::capnp::_::PointerHelpers< ::AvPanelProcessor>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::AvPanelProcessor::Client AvNodeRoot::Pipeline::getPanelProcessor() {
  return  ::AvPanelProcessor::Client(_typeless.getPointerField(2).asCap());
}
inline void AvNodeRoot::Builder::setPanelProcessor( ::AvPanelProcessor::Client&& cap) {
  ::capnp::_::PointerHelpers< ::AvPanelProcessor>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AvNodeRoot::Builder::setPanelProcessor( ::AvPanelProcessor::Client& cap) {
  ::capnp::_::PointerHelpers< ::AvPanelProcessor>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), cap);
}
inline void AvNodeRoot::Builder::adoptPanelProcessor(
    ::capnp::Orphan< ::AvPanelProcessor>&& value) {
  ::capnp::_::PointerHelpers< ::AvPanelProcessor>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvPanelProcessor> AvNodeRoot::Builder::disownPanelProcessor() {
  return ::capnp::_::PointerHelpers< ::AvPanelProcessor>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool AvNodeRoot::Reader::hasGrabberProcessor() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool AvNodeRoot::Builder::hasGrabberProcessor() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::AvGrabberProcessor::Client AvNodeRoot::Reader::getGrabberProcessor() const {
  return ::capnp::_::PointerHelpers< ::AvGrabberProcessor>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::AvGrabberProcessor::Client AvNodeRoot::Builder::getGrabberProcessor() {
  return ::capnp::_::PointerHelpers< ::AvGrabberProcessor>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::AvGrabberProcessor::Client AvNodeRoot::Pipeline::getGrabberProcessor() {
  return  ::AvGrabberProcessor::Client(_typeless.getPointerField(3).asCap());
}
inline void AvNodeRoot::Builder::setGrabberProcessor( ::AvGrabberProcessor::Client&& cap) {
  ::capnp::_::PointerHelpers< ::AvGrabberProcessor>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AvNodeRoot::Builder::setGrabberProcessor( ::AvGrabberProcessor::Client& cap) {
  ::capnp::_::PointerHelpers< ::AvGrabberProcessor>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), cap);
}
inline void AvNodeRoot::Builder::adoptGrabberProcessor(
    ::capnp::Orphan< ::AvGrabberProcessor>&& value) {
  ::capnp::_::PointerHelpers< ::AvGrabberProcessor>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvGrabberProcessor> AvNodeRoot::Builder::disownGrabberProcessor() {
  return ::capnp::_::PointerHelpers< ::AvGrabberProcessor>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool AvNodeRoot::Reader::hasGrabbableProcessor() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool AvNodeRoot::Builder::hasGrabbableProcessor() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::AvGrabbableProcessor::Client AvNodeRoot::Reader::getGrabbableProcessor() const {
  return ::capnp::_::PointerHelpers< ::AvGrabbableProcessor>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::AvGrabbableProcessor::Client AvNodeRoot::Builder::getGrabbableProcessor() {
  return ::capnp::_::PointerHelpers< ::AvGrabbableProcessor>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::AvGrabbableProcessor::Client AvNodeRoot::Pipeline::getGrabbableProcessor() {
  return  ::AvGrabbableProcessor::Client(_typeless.getPointerField(4).asCap());
}
inline void AvNodeRoot::Builder::setGrabbableProcessor( ::AvGrabbableProcessor::Client&& cap) {
  ::capnp::_::PointerHelpers< ::AvGrabbableProcessor>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AvNodeRoot::Builder::setGrabbableProcessor( ::AvGrabbableProcessor::Client& cap) {
  ::capnp::_::PointerHelpers< ::AvGrabbableProcessor>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), cap);
}
inline void AvNodeRoot::Builder::adoptGrabbableProcessor(
    ::capnp::Orphan< ::AvGrabbableProcessor>&& value) {
  ::capnp::_::PointerHelpers< ::AvGrabbableProcessor>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvGrabbableProcessor> AvNodeRoot::Builder::disownGrabbableProcessor() {
  return ::capnp::_::PointerHelpers< ::AvGrabbableProcessor>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool AvNodeRoot::Reader::hasHook() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool AvNodeRoot::Builder::hasHook() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvNodeRoot::Reader::getHook() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvNodeRoot::Builder::getHook() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void AvNodeRoot::Builder::setHook( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvNodeRoot::Builder::initHook(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void AvNodeRoot::Builder::adoptHook(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvNodeRoot::Builder::disownHook() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline AvServer::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline AvServer::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline AvServer::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline AvServer::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline AvServer::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::AvServer::Client& AvServer::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::AvServer::Client& AvServer::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool AvServer::CreateGadgetParams::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvServer::CreateGadgetParams::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvServer::CreateGadgetParams::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvServer::CreateGadgetParams::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvServer::CreateGadgetParams::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvServer::CreateGadgetParams::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvServer::CreateGadgetParams::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvServer::CreateGadgetParams::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvServer::CreateGadgetParams::Reader::hasInitialHook() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvServer::CreateGadgetParams::Builder::hasInitialHook() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvServer::CreateGadgetParams::Reader::getInitialHook() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvServer::CreateGadgetParams::Builder::getInitialHook() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AvServer::CreateGadgetParams::Builder::setInitialHook( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvServer::CreateGadgetParams::Builder::initInitialHook(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void AvServer::CreateGadgetParams::Builder::adoptInitialHook(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvServer::CreateGadgetParams::Builder::disownInitialHook() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AvServer::CreateGadgetResults::Reader::hasGadget() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvServer::CreateGadgetResults::Builder::hasGadget() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::AvGadget::Client AvServer::CreateGadgetResults::Reader::getGadget() const {
  return ::capnp::_::PointerHelpers< ::AvGadget>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvGadget::Client AvServer::CreateGadgetResults::Builder::getGadget() {
  return ::capnp::_::PointerHelpers< ::AvGadget>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvGadget::Client AvServer::CreateGadgetResults::Pipeline::getGadget() {
  return  ::AvGadget::Client(_typeless.getPointerField(0).asCap());
}
inline void AvServer::CreateGadgetResults::Builder::setGadget( ::AvGadget::Client&& cap) {
  ::capnp::_::PointerHelpers< ::AvGadget>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AvServer::CreateGadgetResults::Builder::setGadget( ::AvGadget::Client& cap) {
  ::capnp::_::PointerHelpers< ::AvGadget>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void AvServer::CreateGadgetResults::Builder::adoptGadget(
    ::capnp::Orphan< ::AvGadget>&& value) {
  ::capnp::_::PointerHelpers< ::AvGadget>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvGadget> AvServer::CreateGadgetResults::Builder::disownGadget() {
  return ::capnp::_::PointerHelpers< ::AvGadget>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint32_t AvServer::CreateGadgetResults::Reader::getGadgetId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvServer::CreateGadgetResults::Builder::getGadgetId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvServer::CreateGadgetResults::Builder::setGadgetId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvServer::ListenForFramesParams::Reader::hasListener() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvServer::ListenForFramesParams::Builder::hasListener() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::AvFrameListener::Client AvServer::ListenForFramesParams::Reader::getListener() const {
  return ::capnp::_::PointerHelpers< ::AvFrameListener>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvFrameListener::Client AvServer::ListenForFramesParams::Builder::getListener() {
  return ::capnp::_::PointerHelpers< ::AvFrameListener>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvFrameListener::Client AvServer::ListenForFramesParams::Pipeline::getListener() {
  return  ::AvFrameListener::Client(_typeless.getPointerField(0).asCap());
}
inline void AvServer::ListenForFramesParams::Builder::setListener( ::AvFrameListener::Client&& cap) {
  ::capnp::_::PointerHelpers< ::AvFrameListener>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void AvServer::ListenForFramesParams::Builder::setListener( ::AvFrameListener::Client& cap) {
  ::capnp::_::PointerHelpers< ::AvFrameListener>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), cap);
}
inline void AvServer::ListenForFramesParams::Builder::adoptListener(
    ::capnp::Orphan< ::AvFrameListener>&& value) {
  ::capnp::_::PointerHelpers< ::AvFrameListener>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvFrameListener> AvServer::ListenForFramesParams::Builder::disownListener() {
  return ::capnp::_::PointerHelpers< ::AvFrameListener>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool AvServer::UpdateDxgiTextureForGadgetsParams::Reader::hasGadgetIds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvServer::UpdateDxgiTextureForGadgetsParams::Builder::hasGadgetIds() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader AvServer::UpdateDxgiTextureForGadgetsParams::Reader::getGadgetIds() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder AvServer::UpdateDxgiTextureForGadgetsParams::Builder::getGadgetIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvServer::UpdateDxgiTextureForGadgetsParams::Builder::setGadgetIds( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void AvServer::UpdateDxgiTextureForGadgetsParams::Builder::setGadgetIds(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder AvServer::UpdateDxgiTextureForGadgetsParams::Builder::initGadgetIds(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvServer::UpdateDxgiTextureForGadgetsParams::Builder::adoptGadgetIds(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> AvServer::UpdateDxgiTextureForGadgetsParams::Builder::disownGadgetIds() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvServer::UpdateDxgiTextureForGadgetsParams::Reader::hasSharedTextureInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvServer::UpdateDxgiTextureForGadgetsParams::Builder::hasSharedTextureInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::AvSharedTextureInfo::Reader AvServer::UpdateDxgiTextureForGadgetsParams::Reader::getSharedTextureInfo() const {
  return ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::AvSharedTextureInfo::Builder AvServer::UpdateDxgiTextureForGadgetsParams::Builder::getSharedTextureInfo() {
  return ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvSharedTextureInfo::Pipeline AvServer::UpdateDxgiTextureForGadgetsParams::Pipeline::getSharedTextureInfo() {
  return  ::AvSharedTextureInfo::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void AvServer::UpdateDxgiTextureForGadgetsParams::Builder::setSharedTextureInfo( ::AvSharedTextureInfo::Reader value) {
  ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::AvSharedTextureInfo::Builder AvServer::UpdateDxgiTextureForGadgetsParams::Builder::initSharedTextureInfo() {
  return ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AvServer::UpdateDxgiTextureForGadgetsParams::Builder::adoptSharedTextureInfo(
    ::capnp::Orphan< ::AvSharedTextureInfo>&& value) {
  ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvSharedTextureInfo> AvServer::UpdateDxgiTextureForGadgetsParams::Builder::disownSharedTextureInfo() {
  return ::capnp::_::PointerHelpers< ::AvSharedTextureInfo>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AvServer::UpdateDxgiTextureForGadgetsResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool AvServer::UpdateDxgiTextureForGadgetsResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvServer::UpdateDxgiTextureForGadgetsResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t AvServer::PushPokerProximityParams::Reader::getPokerId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvServer::PushPokerProximityParams::Builder::getPokerId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvServer::PushPokerProximityParams::Builder::setPokerId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvServer::PushPokerProximityParams::Reader::hasProximity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvServer::PushPokerProximityParams::Builder::hasProximity() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Reader AvServer::PushPokerProximityParams::Reader::getProximity() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Builder AvServer::PushPokerProximityParams::Builder::getProximity() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvServer::PushPokerProximityParams::Builder::setProximity( ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>::Builder AvServer::PushPokerProximityParams::Builder::initProximity(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvServer::PushPokerProximityParams::Builder::adoptProximity(
    ::capnp::Orphan< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>> AvServer::PushPokerProximityParams::Builder::disownProximity() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AvPanelProximity,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t AvServer::PushGrabIntersectionsParams::Reader::getGrabberId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvServer::PushGrabIntersectionsParams::Builder::getGrabberId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvServer::PushGrabIntersectionsParams::Builder::setGrabberId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvServer::PushGrabIntersectionsParams::Reader::getIsGrabPressed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool AvServer::PushGrabIntersectionsParams::Builder::getIsGrabPressed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void AvServer::PushGrabIntersectionsParams::Builder::setIsGrabPressed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool AvServer::PushGrabIntersectionsParams::Reader::hasIntersections() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvServer::PushGrabIntersectionsParams::Builder::hasIntersections() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader AvServer::PushGrabIntersectionsParams::Reader::getIntersections() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder AvServer::PushGrabIntersectionsParams::Builder::getIntersections() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvServer::PushGrabIntersectionsParams::Builder::setIntersections( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void AvServer::PushGrabIntersectionsParams::Builder::setIntersections(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder AvServer::PushGrabIntersectionsParams::Builder::initIntersections(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvServer::PushGrabIntersectionsParams::Builder::adoptIntersections(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> AvServer::PushGrabIntersectionsParams::Builder::disownIntersections() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvServer::PushGrabIntersectionsParams::Reader::hasHooks() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AvServer::PushGrabIntersectionsParams::Builder::hasHooks() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader AvServer::PushGrabIntersectionsParams::Reader::getHooks() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder AvServer::PushGrabIntersectionsParams::Builder::getHooks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AvServer::PushGrabIntersectionsParams::Builder::setHooks( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void AvServer::PushGrabIntersectionsParams::Builder::setHooks(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder AvServer::PushGrabIntersectionsParams::Builder::initHooks(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void AvServer::PushGrabIntersectionsParams::Builder::adoptHooks(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> AvServer::PushGrabIntersectionsParams::Builder::disownHooks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline AvGadget::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline AvGadget::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline AvGadget::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline AvGadget::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline AvGadget::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::AvGadget::Client& AvGadget::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::AvGadget::Client& AvGadget::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool AvGadget::NameResults::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvGadget::NameResults::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AvGadget::NameResults::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AvGadget::NameResults::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvGadget::NameResults::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AvGadget::NameResults::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AvGadget::NameResults::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AvGadget::NameResults::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvGadget::DestroyResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool AvGadget::DestroyResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvGadget::DestroyResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvGadget::UpdateSceneGraphParams::Reader::hasRoot() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvGadget::UpdateSceneGraphParams::Builder::hasRoot() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvNodeRoot::Reader AvGadget::UpdateSceneGraphParams::Reader::getRoot() const {
  return ::capnp::_::PointerHelpers< ::AvNodeRoot>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvNodeRoot::Builder AvGadget::UpdateSceneGraphParams::Builder::getRoot() {
  return ::capnp::_::PointerHelpers< ::AvNodeRoot>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvNodeRoot::Pipeline AvGadget::UpdateSceneGraphParams::Pipeline::getRoot() {
  return  ::AvNodeRoot::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvGadget::UpdateSceneGraphParams::Builder::setRoot( ::AvNodeRoot::Reader value) {
  ::capnp::_::PointerHelpers< ::AvNodeRoot>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvNodeRoot::Builder AvGadget::UpdateSceneGraphParams::Builder::initRoot() {
  return ::capnp::_::PointerHelpers< ::AvNodeRoot>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvGadget::UpdateSceneGraphParams::Builder::adoptRoot(
    ::capnp::Orphan< ::AvNodeRoot>&& value) {
  ::capnp::_::PointerHelpers< ::AvNodeRoot>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvNodeRoot> AvGadget::UpdateSceneGraphParams::Builder::disownRoot() {
  return ::capnp::_::PointerHelpers< ::AvNodeRoot>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AvGadget::UpdateSceneGraphResults::Reader::getSuccess() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool AvGadget::UpdateSceneGraphResults::Builder::getSuccess() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvGadget::UpdateSceneGraphResults::Builder::setSuccess(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t AvGadget::PushMouseEventParams::Reader::getPokerNodeId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvGadget::PushMouseEventParams::Builder::getPokerNodeId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvGadget::PushMouseEventParams::Builder::setPokerNodeId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvGadget::PushMouseEventParams::Reader::hasEvent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvGadget::PushMouseEventParams::Builder::hasEvent() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvPanelMouseEvent::Reader AvGadget::PushMouseEventParams::Reader::getEvent() const {
  return ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvPanelMouseEvent::Builder AvGadget::PushMouseEventParams::Builder::getEvent() {
  return ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvPanelMouseEvent::Pipeline AvGadget::PushMouseEventParams::Pipeline::getEvent() {
  return  ::AvPanelMouseEvent::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvGadget::PushMouseEventParams::Builder::setEvent( ::AvPanelMouseEvent::Reader value) {
  ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvPanelMouseEvent::Builder AvGadget::PushMouseEventParams::Builder::initEvent() {
  return ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvGadget::PushMouseEventParams::Builder::adoptEvent(
    ::capnp::Orphan< ::AvPanelMouseEvent>&& value) {
  ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvPanelMouseEvent> AvGadget::PushMouseEventParams::Builder::disownEvent() {
  return ::capnp::_::PointerHelpers< ::AvPanelMouseEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t AvGadget::SendHapticEventParams::Reader::getNodeGlobalId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AvGadget::SendHapticEventParams::Builder::getNodeGlobalId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvGadget::SendHapticEventParams::Builder::setNodeGlobalId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float AvGadget::SendHapticEventParams::Reader::getAmplitude() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float AvGadget::SendHapticEventParams::Builder::getAmplitude() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AvGadget::SendHapticEventParams::Builder::setAmplitude(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float AvGadget::SendHapticEventParams::Reader::getFrequency() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float AvGadget::SendHapticEventParams::Builder::getFrequency() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void AvGadget::SendHapticEventParams::Builder::setFrequency(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float AvGadget::SendHapticEventParams::Reader::getDuration() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float AvGadget::SendHapticEventParams::Builder::getDuration() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void AvGadget::SendHapticEventParams::Builder::setDuration(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t AvGadget::PushGrabEventParams::Reader::getGrabberNodeId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AvGadget::PushGrabEventParams::Builder::getGrabberNodeId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AvGadget::PushGrabEventParams::Builder::setGrabberNodeId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AvGadget::PushGrabEventParams::Reader::hasEvent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AvGadget::PushGrabEventParams::Builder::hasEvent() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AvGrabEvent::Reader AvGadget::PushGrabEventParams::Reader::getEvent() const {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AvGrabEvent::Builder AvGadget::PushGrabEventParams::Builder::getEvent() {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AvGrabEvent::Pipeline AvGadget::PushGrabEventParams::Pipeline::getEvent() {
  return  ::AvGrabEvent::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AvGadget::PushGrabEventParams::Builder::setEvent( ::AvGrabEvent::Reader value) {
  ::capnp::_::PointerHelpers< ::AvGrabEvent>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AvGrabEvent::Builder AvGadget::PushGrabEventParams::Builder::initEvent() {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AvGadget::PushGrabEventParams::Builder::adoptEvent(
    ::capnp::Orphan< ::AvGrabEvent>&& value) {
  ::capnp::_::PointerHelpers< ::AvGrabEvent>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AvGrabEvent> AvGadget::PushGrabEventParams::Builder::disownEvent() {
  return ::capnp::_::PointerHelpers< ::AvGrabEvent>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


